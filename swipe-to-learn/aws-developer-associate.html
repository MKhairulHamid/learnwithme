<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AWS Developer Associate - Swipe To Learn | Learn With Me</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0A2540 0%, #1A3B5C 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            color: white;
            padding: 20px 0;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .progress-bar {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            height: 8px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            background: #4ade80;
            height: 100%;
            transition: width 0.3s ease;
        }

        .progress-text {
            color: white;
            text-align: center;
            font-size: 14px;
            margin-top: 10px;
        }

        .timer-container {
            display: flex;
            flex-direction: column;
            color: white;
            margin: 10px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            transition: background 0.5s ease;
        }

        .timer-display {
            font-size: 18px;
            font-weight: 600;
            transition: color 0.5s ease;
            text-align: center;
            margin-bottom: 10px;
        }

        .timer-progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .timer-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            border-radius: 10px;
            transition: width 1s linear, background 0.5s ease;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
        }

        .timer-progress-fill.warning {
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        .timer-progress-fill.critical {
            background: linear-gradient(90deg, #ef4444, #dc2626);
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }

        .question-navigation {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            backdrop-filter: blur(10px);
        }

        .nav-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            color: white;
        }

        .nav-header h3 {
            font-size: 16px;
            margin: 0;
        }

        .toggle-nav-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .toggle-nav-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .question-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
            gap: 8px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .question-grid.show {
            max-height: 500px;
            overflow-y: auto;
        }

        .question-nav-item {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid transparent;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .question-nav-item:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .question-nav-item.answered {
            background: #4ade80;
            color: #065f46;
        }

        .question-nav-item.current {
            border-color: #fbbf24;
            box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.5);
        }

        .nav-legend {
            display: flex;
            gap: 15px;
            margin-top: 12px;
            font-size: 12px;
            color: white;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .legend-box.answered {
            background: #4ade80;
        }

        .legend-box.unanswered {
            background: rgba(255, 255, 255, 0.2);
        }

        .legend-box.current {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #fbbf24;
        }

        .card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
            position: relative;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .card.swipe-left {
            transform: scale(0.8) rotate(-10deg);
            opacity: 0;
        }

        .card.swipe-right {
            transform: scale(0.8) rotate(10deg);
            opacity: 0;
        }

        .question-type {
            display: inline-block;
            background: #0A2540;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            margin-bottom: 15px;
        }

        .question-text {
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .answers {
            margin-bottom: 20px;
        }

        .answer-option {
            background: #f3f4f6;
            border: 2px solid transparent;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            user-select: none;
        }

        .answer-option:hover {
            background: #e5e7eb;
        }

        .answer-option.selected {
            background: #dbeafe;
            border-color: #3b82f6;
        }

        .answer-option.correct {
            background: #d1fae5;
            border-color: #10b981;
        }

        .answer-option.incorrect {
            background: #fee2e2;
            border-color: #ef4444;
        }

        .answer-checkbox {
            width: 24px;
            height: 24px;
            border: 2px solid #9ca3af;
            border-radius: 6px;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .answer-option.selected .answer-checkbox {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        .answer-option.selected .answer-checkbox::after {
            content: '‚úì';
            color: white;
            font-weight: bold;
        }

        .answer-text {
            flex: 1;
            color: #374151;
            font-size: 15px;
        }

        .materials-btn {
            width: 100%;
            background: #fef3c7;
            border: 2px solid #f59e0b;
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #92400e;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(245, 158, 11, 0.1);
        }

        .materials-btn:hover {
            background: #fde68a;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(245, 158, 11, 0.2);
        }

        .materials-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(245, 158, 11, 0.1);
        }

        .materials-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(10, 37, 64, 0.97) 0%, rgba(26, 59, 92, 0.97) 100%);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(20px);
            padding: 20px;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .materials-overlay.show {
            display: flex;
        }

        .materials-modal {
            background: linear-gradient(to bottom, #ffffff 0%, #fefefe 100%);
            border-radius: 24px;
            padding: 0;
            max-width: 650px;
            width: 100%;
            max-height: 90vh;
            overflow: hidden;
            position: relative;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.4), 
                        0 0 0 1px rgba(255, 255, 255, 0.1);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .materials-header {
            background: linear-gradient(135deg, #0A2540 0%, #1e3a5f 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 24px 28px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .materials-header h3 {
            font-size: 20px;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .materials-close-btn {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 22px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
            font-weight: 300;
        }

        .materials-close-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: rotate(90deg);
        }

        .materials-content {
            background: linear-gradient(to bottom, #fffef9 0%, #fffcf0 100%);
            padding: 32px;
            font-size: 14.5px;
            line-height: 1.9;
            color: #2d3748;
            white-space: pre-line;
            overflow-y: auto;
            max-height: calc(90vh - 76px);
            box-shadow: inset 0 4px 6px rgba(0, 0, 0, 0.02);
        }

        .materials-content::-webkit-scrollbar {
            width: 8px;
        }

        .materials-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }

        .materials-content::-webkit-scrollbar-thumb {
            background: rgba(10, 37, 64, 0.3);
            border-radius: 4px;
        }

        .materials-content::-webkit-scrollbar-thumb:hover {
            background: rgba(10, 37, 64, 0.5);
        }


        .results-container {
            display: none;
        }

        .results-container.show {
            display: block;
        }

        .score-card {
            background: white;
            border-radius: 20px;
            padding: 40px 30px;
            text-align: center;
            margin-bottom: 20px;
        }

        .score-number {
            font-size: 72px;
            font-weight: bold;
            color: #0A2540;
            margin: 20px 0;
        }

        .score-label {
            font-size: 18px;
            color: #6b7280;
            margin-bottom: 10px;
        }

        .pass-status {
            display: inline-block;
            padding: 10px 30px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: 600;
            margin-top: 20px;
        }

        .pass-status.pass {
            background: #d1fae5;
            color: #065f46;
        }

        .pass-status.fail {
            background: #fee2e2;
            color: #991b1b;
        }

        .review-header {
            color: white;
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 20px;
            text-align: center;
        }

        .review-question {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
        }

        .review-question-number {
            font-size: 14px;
            font-weight: 600;
            color: #0A2540;
            margin-bottom: 10px;
        }

        .review-question-text {
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 15px;
        }

        .review-answer {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .review-answer.user-answer {
            background: #dbeafe;
            border-left: 4px solid #3b82f6;
        }

        .review-answer.correct-answer {
            background: #d1fae5;
            border-left: 4px solid #10b981;
        }

        .review-answer.wrong-answer {
            background: #fee2e2;
            border-left: 4px solid #ef4444;
        }

        .explanation {
            background: #f9fafb;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
            line-height: 1.6;
            color: #374151;
        }

        .explanation-title {
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 8px;
        }

        .start-container {
            text-align: center;
        }

        .start-btn {
            background: white;
            color: #0A2540;
            border: none;
            padding: 20px 50px;
            font-size: 18px;
            font-weight: 600;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease;
        }

        .start-btn:hover {
            transform: translateY(-2px);
        }

        .exam-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            color: white;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .exam-info h2 {
            font-size: 20px;
            margin-bottom: 15px;
        }

        .exam-info ul {
            list-style: none;
            padding-left: 0;
        }

        .exam-info li {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .exam-info li:last-child {
            border-bottom: none;
        }

        .unanswered-tag {
            display: inline-block;
            background: #fef3c7;
            color: #92400e;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        @media (min-width: 768px) {
            .header h1 {
                font-size: 28px;
            }
            
            .question-text {
                font-size: 20px;
            }
        }

        .desktop-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .desktop-btn {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .desktop-btn.prev {
            background: #e5e7eb;
            color: #374151;
        }

        .desktop-btn.next {
            background: #4ade80;
            color: #065f46;
        }

        .desktop-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .hidden {
            display: none;
        }

        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 37, 64, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .pause-overlay.show {
            display: flex;
        }

        .pause-modal {
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .pause-modal h2 {
            font-size: 28px;
            color: #0A2540;
            margin-bottom: 20px;
        }

        .pause-modal p {
            color: #6b7280;
            margin-bottom: 30px;
            font-size: 16px;
        }

        .pause-buttons {
            display: flex;
            gap: 15px;
        }

        .pause-btn {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .pause-btn.continue {
            background: #d1fae5;
            color: #065f46;
        }

        .pause-btn.restart {
            background: #fee2e2;
            color: #991b1b;
        }

        .pause-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .previous-results {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            color: white;
            margin-top: 20px;
            backdrop-filter: blur(10px);
        }

        .previous-results h3 {
            font-size: 18px;
            margin-bottom: 15px;
        }

        .result-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .result-item .result-score {
            font-weight: 600;
            font-size: 18px;
        }

        .result-item .result-date {
            font-size: 12px;
            opacity: 0.8;
        }

        .result-item.passed {
            border-left: 4px solid #10b981;
        }

        .result-item.failed {
            border-left: 4px solid #ef4444;
        }

        .submit-screen {
            display: none;
        }

        .submit-screen.show {
            display: block;
        }

        .submit-card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
        }

        .submit-card h2 {
            color: #0A2540;
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-box {
            background: #f3f4f6;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-number {
            font-size: 32px;
            font-weight: bold;
            color: #0A2540;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 14px;
            color: #6b7280;
        }

        .stat-box.answered {
            background: #d1fae5;
        }

        .stat-box.answered .stat-number {
            color: #065f46;
        }

        .stat-box.unanswered {
            background: #fee2e2;
        }

        .stat-box.unanswered .stat-number {
            color: #991b1b;
        }

        .submit-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .submit-btn {
            flex: 1;
            padding: 18px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .submit-btn.back {
            background: #e5e7eb;
            color: #374151;
        }

        .submit-btn.confirm {
            background: #4ade80;
            color: #065f46;
        }

        .submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .warning-message {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            color: #92400e;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Swipe To Learn</h1>
            <p>AWS Certified Developer - Associate</p>
        </div>

        <!-- Start Screen -->
        <div id="startScreen" class="start-container">
            <div class="exam-info">
                <h2>üìã Practice Exam Information</h2>
                <ul>
                    <li><strong>Total Questions:</strong> 65</li>
                    <li><strong>Question Types:</strong> Multiple Choice & Multiple Response</li>
                    <li><strong>Duration:</strong> ~130 minutes (simulates real exam)</li>
                    <li><strong>Passing Score:</strong> 720/1000 points</li>
                    <li style="height: 10px;"></li>
                    <li><strong>üìö Content Domains:</strong></li>
                    <li style="margin-left: 20px;">‚Ä¢ Development with AWS Services (32%)</li>
                    <li style="margin-left: 20px;">‚Ä¢ Security (26%)</li>
                    <li style="margin-left: 20px;">‚Ä¢ Deployment (24%)</li>
                    <li style="margin-left: 20px;">‚Ä¢ Troubleshooting & Optimization (18%)</li>
                    <li style="height: 10px;"></li>
                    <li><strong>üì± Navigation:</strong></li>
                    <li style="margin-left: 20px;">‚Ä¢ Swipe left for next, swipe right for previous</li>
                </ul>
            </div>
            <div id="startButtons">
                <button class="start-btn" onclick="startExam()" id="startBtn">Start Practice Exam</button>
            </div>
            <div id="resumeButtons" style="display: none;">
                <button class="start-btn" onclick="startExam()" style="background: #4ade80; margin-bottom: 15px;">
                    ‚ñ∂Ô∏è Continue Saved Exam
                </button>
                <button class="start-btn" onclick="startNewExam()" style="background: #fee2e2; color: #991b1b;">
                    üîÑ Start New Exam
                </button>
                <p style="color: white; margin-top: 20px; text-align: center; opacity: 0.9; font-size: 14px;">
                    ‚ÑπÔ∏è You have a saved exam in progress
                </p>
            </div>
        </div>

        <!-- Exam Screen -->
        <div id="examScreen" class="hidden">
            <div class="timer-container">
                <div class="timer-display" id="timerDisplay">‚è±Ô∏è Time Remaining: 02:10:00</div>
                <div class="timer-progress-bar">
                    <div class="timer-progress-fill" id="timerProgressFill" style="width: 100%;"></div>
                </div>
            </div>

            <div class="question-navigation">
                <div class="nav-header">
                    <h3>üìç Question Navigation</h3>
                    <button class="toggle-nav-btn" onclick="toggleNavigation()">Show All</button>
                </div>
                <div class="question-grid" id="questionGrid"></div>
                <div class="nav-legend">
                    <div class="legend-item">
                        <div class="legend-box answered"></div>
                        <span>Answered</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box unanswered"></div>
                        <span>Unanswered</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box current"></div>
                        <span>Current</span>
                    </div>
                </div>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText"></div>

            <div id="questionCard" class="card">
                <span class="question-type" id="questionType"></span>
                <div class="question-text" id="questionText"></div>
                
                <button class="materials-btn" onclick="toggleMaterials()">
                    üí° Show Related Materials
                </button>
                
                <div class="answers" id="answersContainer"></div>

                <div class="desktop-buttons">
                    <button class="desktop-btn prev" onclick="previousQuestion()" id="prevBtn">‚Üê Previous</button>
                    <button class="desktop-btn next" onclick="nextQuestion()" id="nextBtn">Next ‚Üí</button>
                </div>
            </div>
        </div>

        <!-- Submit Screen -->
        <div id="submitScreen" class="submit-screen">
            <div class="submit-card">
                <h2>üìù Review Your Exam</h2>
                
                <div class="summary-stats">
                    <div class="stat-box answered">
                        <div class="stat-number" id="submitAnsweredCount">0</div>
                        <div class="stat-label">Answered</div>
                    </div>
                    <div class="stat-box unanswered">
                        <div class="stat-number" id="submitUnansweredCount">0</div>
                        <div class="stat-label">Unanswered</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-number" id="submitTotalCount">0</div>
                        <div class="stat-label">Total</div>
                    </div>
                </div>

                <div class="warning-message" id="warningMessage" style="display: none;">
                    ‚ö†Ô∏è You have unanswered questions. You can go back to answer them or submit anyway.
                </div>

                <p style="text-align: center; color: #6b7280; margin: 20px 0;">
                    Are you ready to submit your exam? Once submitted, you cannot change your answers.
                </p>

                <div class="submit-buttons">
                    <button class="submit-btn back" onclick="backToExam()">
                        ‚Üê Back to Exam
                    </button>
                    <button class="submit-btn confirm" onclick="confirmSubmit()">
                        Submit Exam ‚úì
                    </button>
                </div>
            </div>
        </div>

        <!-- Results Screen -->
        <div id="resultsScreen" class="results-container">
            <div class="score-card">
                <div class="score-label">Your Score</div>
                <div class="score-number" id="finalScore"></div>
                <div class="score-label">Out of 1000</div>
                <div class="pass-status" id="passStatus"></div>
                <p style="margin-top: 20px; color: #6b7280;">
                    <span id="correctCount"></span> correct out of <span id="totalCount"></span> questions
                </p>
            </div>

            <div class="previous-results" id="previousResults">
                <h3>üìà Previous Results</h3>
                <div id="resultsHistory"></div>
            </div>

            <h2 class="review-header">üìù Question Review</h2>
            <div id="reviewContainer"></div>
        </div>

        <!-- Pause Overlay -->
        <div class="pause-overlay" id="pauseOverlay">
            <div class="pause-modal">
                <h2>‚è∏Ô∏è Exam Paused</h2>
                <p>The exam has been paused due to inactivity or loss of focus.</p>
                <div class="pause-buttons">
                    <button class="pause-btn continue" onclick="resumeExam()">Continue Exam</button>
                    <button class="pause-btn restart" onclick="confirmRestart()">Restart Exam</button>
                </div>
            </div>
        </div>

        <!-- Materials Overlay -->
        <div class="materials-overlay" id="materialsOverlay" onclick="closeMaterialsOnBackdrop(event)">
            <div class="materials-modal" onclick="event.stopPropagation()">
                <div class="materials-header">
                    <h3>üìö Study Materials</h3>
                    <button class="materials-close-btn" onclick="closeMaterials()">√ó</button>
                </div>
                <div class="materials-content" id="materialsContent"></div>
            </div>
        </div>
    </div>

    <script>
        const questions = [
            // DOMAIN 1: Development with AWS Services (32% - 21 questions)
            {
                id: 1,
                domain: "Development",
                type: "Multiple Choice",
                question: "A developer is building a serverless application using AWS Lambda. The function needs to process messages from an Amazon SQS queue. What is the MOST efficient way to trigger the Lambda function?",
                options: [
                    { text: "Configure CloudWatch Events to poll the queue and trigger Lambda", correct: false },
                    { text: "Use an SQS event source mapping for Lambda", correct: true },
                    { text: "Create an EC2 instance to poll SQS and invoke Lambda via SDK", correct: false },
                    { text: "Use Amazon SNS to subscribe Lambda to the queue", correct: false }
                ],
                materials: "AWS Lambda Event Source Mappings:\n\nLambda can be triggered by various AWS services, but the integration method differs. For SQS, Lambda uses an 'event source mapping' - a Lambda resource that reads from your queue and invokes your function.\n\nHow It Works:\n‚Ä¢ Lambda service polls the SQS queue on your behalf (you don't write polling code)\n‚Ä¢ Retrieves messages in batches (configurable: 1-10 for standard, 1-10000 for FIFO)\n‚Ä¢ Invokes your function synchronously with the batch\n‚Ä¢ Automatically deletes messages after successful processing\n\nKey Benefits:\n‚úì No polling infrastructure needed (no EC2, no cost for polling)\n‚úì Automatic scaling based on queue depth\n‚úì Built-in error handling and retry logic\n‚úì Dead letter queue (DLQ) support for failed messages\n\nConfiguration Options:\n‚Ä¢ Batch size: How many messages per invocation\n‚Ä¢ Batch window: Max time to gather messages\n‚Ä¢ Concurrent batches: How many function invocations in parallel\n‚Ä¢ Error handling: Retry attempts and failure destinations\n\nCommon Patterns:\n- Standard Queue: At-least-once delivery, best effort ordering\n- FIFO Queue: Exactly-once processing, strict ordering\n- Partial batch failures: Return failed message IDs to retry\n\nImportant: The Lambda execution role needs sqs:ReceiveMessage, sqs:DeleteMessage, and sqs:GetQueueAttributes permissions.",
                explanations: {
                    "Configure CloudWatch Events to poll the queue and trigger Lambda": "Incorrect. CloudWatch Events (EventBridge) cannot directly poll SQS queues.",
                    "Use an SQS event source mapping for Lambda": "Correct! Event source mapping is the native and most efficient way to integrate Lambda with SQS. Lambda automatically polls the queue, retrieves messages in batches, and invokes your function.",
                    "Create an EC2 instance to poll SQS and invoke Lambda via SDK": "Incorrect. This adds unnecessary complexity and cost. Lambda can integrate directly with SQS.",
                    "Use Amazon SNS to subscribe Lambda to the queue": "Incorrect. SNS subscribes to topics, not queues. This adds an unnecessary intermediary service."
                }
            },
            {
                id: 2,
                domain: "Development",
                type: "Multiple Choice",
                question: "A developer needs to store user session data for a web application running on multiple EC2 instances behind an Application Load Balancer. What is the BEST solution for sharing session data?",
                options: [
                    { text: "Enable sticky sessions on the load balancer", correct: false },
                    { text: "Store session data in Amazon ElastiCache", correct: true },
                    { text: "Store session data in local EC2 instance storage", correct: false },
                    { text: "Use Amazon EFS mounted on all EC2 instances", correct: false }
                ],
                materials: "Distributed Session Management:\n\nIn a load-balanced environment with multiple servers, session data can't be stored locally on individual instances. The challenge: when a user's request goes to Server A, then Server B on the next request, Server B won't have their session data.\n\nSolution Options Compared:\n\nSticky Sessions (Session Affinity):\n‚Ä¢ Routes user to same instance\n‚Ä¢ ‚ùå Problem: If instance fails, all sessions are lost\n‚Ä¢ ‚ùå Problem: Uneven load distribution\n‚Ä¢ Not a real solution, just a workaround\n\nElastiCache (Redis/Memcached):\n‚úì In-memory data store (microsecond latency)\n‚úì All instances access same session data\n‚úì Survives instance failures\n‚úì Supports millions of requests per second\n‚úì Redis offers persistence and replication\n‚úì Memcached is simpler, great for pure caching\n\nWhen to Use Each:\n‚Ä¢ Redis: Need persistence, complex data types, pub/sub\n‚Ä¢ Memcached: Simple caching, horizontal scaling\n\nImplementation Pattern:\n1. User logs in ‚Üí Session created in ElastiCache\n2. Session ID stored in cookie\n3. Each request sends cookie\n4. Any server can fetch session from ElastiCache\n5. Fast reads/writes (sub-millisecond)\n\nAlternatives (Not Recommended):\n‚Ä¢ EFS: File system, too slow for session data\n‚Ä¢ DynamoDB: Works but higher latency than ElastiCache\n‚Ä¢ Local storage: Doesn't work in distributed systems\n\nBest Practice: Use ElastiCache Redis with Multi-AZ for high availability and automatic failover.",
                explanations: {
                    "Enable sticky sessions on the load balancer": "Incorrect. Sticky sessions don't solve the problem if an instance fails. Users lose their session data.",
                    "Store session data in Amazon ElastiCache": "Correct! ElastiCache (Redis or Memcached) provides fast, shared session storage accessible by all EC2 instances, supporting horizontal scaling.",
                    "Store session data in local EC2 instance storage": "Incorrect. Local storage isn't shared across instances, breaking the session when load balancer routes to a different instance.",
                    "Use Amazon EFS mounted on all EC2 instances": "Incorrect. EFS works but has higher latency than ElastiCache. Not optimal for frequently accessed session data."
                }
            },
            {
                id: 3,
                type: "Multiple Choice",
                question: "Which of the following best describes a stateless application?",
                options: [
                    { text: "It maintains user session data on the server", correct: false },
                    { text: "It stores all client data in a centralized database", correct: false },
                    { text: "It does not store any client session data on the server", correct: true },
                    { text: "It requires a dedicated server for each client session", correct: false }
                ],
                materials: "Stateless vs Stateful Applications:\n\nState = Data that persists between requests\n\nStateless Applications:\n‚úì Each request is independent and self-contained\n‚úì No memory of previous requests\n‚úì All needed data included in each request (tokens, IDs, etc.)\n‚úì Any server can handle any request\n‚úì Easy to scale horizontally (add more servers)\n‚úì No session cleanup needed\n\nReal-World Example:\n‚Ä¢ HTTP is stateless - each request includes all info\n‚Ä¢ REST APIs are typically stateless\n‚Ä¢ User sends: GET /api/users/123 with auth token\n‚Ä¢ Server doesn't remember previous requests\n\nStateful Applications:\n‚úì Server remembers client state between requests\n‚úì Session data stored on server\n‚úì Subsequent requests rely on stored state\n‚úì More complex to scale (need session sharing)\n\nReal-World Example:\n‚Ä¢ Traditional login sessions stored on server\n‚Ä¢ Shopping cart maintained server-side\n‚Ä¢ WebSocket connections (continuous state)\n\nWhy Stateless is Preferred in Cloud:\n1. Horizontal Scaling: Add servers without session sync issues\n2. Load Balancing: Any request can go to any server\n3. Resilience: If a server fails, no sessions are lost\n4. Simplicity: No session management overhead\n\nHow to Make Apps Stateless:\n‚Ä¢ Use JWT tokens (self-contained, no server storage)\n‚Ä¢ Store session data client-side (encrypted cookies)\n‚Ä¢ Use external session stores (ElastiCache, DynamoDB)\n‚Ä¢ Pass all context in each API call\n\nAWS Services That Are Stateless:\n‚Ä¢ Lambda functions (ephemeral, no retained state)\n‚Ä¢ API Gateway (no memory between requests)\n‚Ä¢ S3 (object storage, no session concept)\n\nKey Principle: Stateless doesn't mean no data storage. It means no session state between requests. Data goes to databases, but each request is independent.",
                explanations: {
                    "It maintains user session data on the server": "Incorrect. This describes a stateful application. Stateful applications keep track of user sessions and their data on the server between requests.",
                    "It stores all client data in a centralized database": "Incorrect. While stateless applications might use databases, storing client data in a database doesn't define statefulness. The key is whether session information is maintained between requests.",
                    "It does not store any client session data on the server": "Correct! Stateless applications don't maintain session data on the server between requests. Each request must contain all the information needed to process it. This makes the application easier to scale horizontally since any server can handle any request.",
                    "It requires a dedicated server for each client session": "Incorrect. This is actually the opposite of what stateless applications need. Stateless applications don't require dedicated servers per session‚Äîany server can handle any request, which is one of their main advantages."
                }
            },
            {
                id: 4,
                type: "Multiple Choice",
                question: "What is a key difference between tightly coupled and loosely coupled components in a system?",
                options: [
                    { text: "Tightly coupled components are easier to scale horizontally", correct: false },
                    { text: "Loosely coupled components depend heavily on each other", correct: false },
                    { text: "Tightly coupled components have strong dependencies, making changes more complex", correct: true },
                    { text: "Loosely coupled components require synchronous communication", correct: false }
                ],
                materials: "System Coupling - Component Dependencies:\n\nCoupling = How much components depend on each other\n\nTightly Coupled Systems:\n‚ùå Components know about each other's internals\n‚ùå Direct function/method calls between components\n‚ùå Changes in one component break others\n‚ùå Hard to test components in isolation\n‚ùå Difficult to scale or replace components\n‚ùå Monolithic architecture tendency\n\nExample of Tight Coupling:\n```\n// OrderService directly calls PaymentService methods\nclass OrderService {\n  processOrder() {\n    paymentService.validateCard()\n    paymentService.chargeAmount()\n    paymentService.sendReceipt()\n  }\n}\n```\nProblem: If PaymentService changes its methods, OrderService breaks.\n\nLoosely Coupled Systems:\n‚úì Components interact through interfaces/contracts\n‚úì Communication via messages or events\n‚úì Changes in one don't affect others\n‚úì Easy to test with mocks\n‚úì Components can be scaled independently\n‚úì Microservices architecture friendly\n\nExample of Loose Coupling:\n```\n// OrderService sends event to queue\nclass OrderService {\n  processOrder() {\n    queue.send({type: 'ORDER_CREATED', data: order})\n  }\n}\n// PaymentService subscribes to queue independently\n```\nBenefit: Services don't know about each other. Can evolve separately.\n\nAWS Services That Enable Loose Coupling:\n‚Ä¢ SQS: Message queues decouple services\n‚Ä¢ SNS: Pub/sub for event distribution\n‚Ä¢ EventBridge: Event-driven architecture\n‚Ä¢ API Gateway: Abstract backend implementations\n‚Ä¢ Step Functions: Orchestrate without tight coupling\n\nReal-World Benefits:\n1. Team Independence: Different teams work on different services\n2. Technology Freedom: Use different languages per service\n3. Easier Debugging: Isolate problems to specific components\n4. Better Scaling: Scale only the components under load\n5. Risk Reduction: Updates don't cascade failures\n\nHow to Achieve Loose Coupling:\n‚Ä¢ Use message queues instead of direct calls\n‚Ä¢ Define clear API contracts (OpenAPI, GraphQL schemas)\n‚Ä¢ Implement circuit breakers for fault tolerance\n‚Ä¢ Use service discovery instead of hardcoded endpoints\n‚Ä¢ Adopt event-driven patterns\n\nKey Principle: Aim for loose coupling and high cohesion (related functionality grouped together).",
                explanations: {
                    "Tightly coupled components are easier to scale horizontally": "Incorrect. Tightly coupled components are actually harder to scale horizontally because they have strong dependencies on each other. Loosely coupled components are easier to scale.",
                    "Loosely coupled components depend heavily on each other": "Incorrect. This describes tightly coupled components. Loosely coupled components have minimal dependencies and can function independently.",
                    "Tightly coupled components have strong dependencies, making changes more complex": "Correct! In tightly coupled systems, components are highly dependent on each other. When you change one component, you often need to modify multiple other components, increasing complexity and reducing flexibility.",
                    "Loosely coupled components require synchronous communication": "Incorrect. Loosely coupled components often use asynchronous communication patterns (like message queues or events) rather than synchronous calls. This further reduces dependencies."
                }
            },
            {
                id: 5,
                type: "Multiple Response",
                question: "In an event-driven architecture, which of the following are characteristics of the fanout pattern? (Select TWO)",
                options: [
                    { text: "It aggregates multiple events into a single event", correct: false },
                    { text: "It distributes a single event to multiple consumers", correct: true },
                    { text: "It synchronizes events between services", correct: false },
                    { text: "It enables parallel processing by multiple services", correct: true },
                    { text: "It filters events based on predefined criteria", correct: false }
                ],
                materials: "Fanout Pattern - Event-Driven Architecture:\n\nFanout = One event ‚Üí Many consumers simultaneously\n\nCore Concept:\nWhen something happens (an event), multiple independent services need to react to it. Instead of the source calling each service directly, it broadcasts the event once, and all interested services receive it.\n\nHow It Works:\n1. Event occurs (e.g., \"User Registered\")\n2. Event published to SNS topic or EventBridge\n3. Multiple subscribers receive event in parallel\n4. Each processes independently\n5. No coordination between consumers\n\nReal-World Example - User Registration:\n```\nEvent: USER_REGISTERED\n‚îú‚Üí Email Service: Send welcome email\n‚îú‚Üí Analytics Service: Track new user\n‚îú‚Üí CRM Service: Create customer profile\n‚îú‚Üí Notification Service: Send push notification\n‚îî‚Üí Audit Service: Log registration\n```\n\nAll happen simultaneously, in parallel!\n\nKey Characteristics:\n‚úì One-to-Many: Single event, multiple receivers\n‚úì Parallel Processing: All consumers work at same time\n‚úì Independence: Consumers don't know about each other\n‚úì Asynchronous: Fire and forget\n‚úì Scalable: Add new consumers without changing source\n\nAWS Implementation:\n\n1. Using SNS (Simple Notification Service):\n   ‚Ä¢ Create SNS topic\n   ‚Ä¢ Services subscribe (SQS, Lambda, HTTP, email)\n   ‚Ä¢ Publish message once ‚Üí delivered to all\n\n2. Using EventBridge:\n   ‚Ä¢ Define event bus\n   ‚Ä¢ Multiple rules route to different targets\n   ‚Ä¢ Advanced filtering capabilities\n\n3. Using SNS + SQS (Fan-out Pattern):\n   ‚Ä¢ SNS topic\n   ‚Ä¢ Multiple SQS queues subscribed\n   ‚Ä¢ Each queue processes independently\n   ‚Ä¢ Benefit: Reliable delivery per consumer\n\nBenefits:\n‚Ä¢ Decoupling: Source doesn't know consumers\n‚Ä¢ Scalability: Easy to add new subscribers\n‚Ä¢ Parallel Processing: Faster overall completion\n‚Ä¢ Reliability: One service failure doesn't affect others\n‚Ä¢ Flexibility: Different services process differently\n\nCommon Use Cases:\n‚Ä¢ Order processing (inventory, shipping, billing)\n‚Ä¢ User actions (notifications, analytics, logging)\n‚Ä¢ IoT data (multiple processors for same sensor data)\n‚Ä¢ CI/CD pipelines (test, build, deploy)\n\nAnti-Pattern (What NOT to Do):\n‚ùå Source service calls each consumer directly\n‚ùå Sequential processing when parallel is possible\n‚ùå Tight coupling between source and consumers\n\nKey Difference from Other Patterns:\n‚Ä¢ Fanout ‚â† Aggregation (opposite direction)\n‚Ä¢ Fanout ‚â† Filtering (sends to all, no filtering)\n‚Ä¢ Fanout ‚â† Request-Response (one-way, async)",
                explanations: {
                    "It aggregates multiple events into a single event": "Incorrect. This describes an aggregation or consolidation pattern, not fanout. Fanout does the opposite‚Äîit takes one event and distributes it to many consumers.",
                    "It distributes a single event to multiple consumers": "Correct! This is the core characteristic of the fanout pattern. One event is published and multiple consumers receive it, allowing each to process it according to their needs.",
                    "It synchronizes events between services": "Incorrect. Fanout doesn't synchronize events‚Äîit broadcasts them. Services receive events asynchronously and process them independently without coordination.",
                    "It enables parallel processing by multiple services": "Correct! Because multiple consumers receive the same event simultaneously, they can all process it in parallel. This is a key benefit of the fanout pattern for performance and scalability.",
                    "It filters events based on predefined criteria": "Incorrect. This describes a filtering or routing pattern. Fanout broadcasts to all consumers without filtering. Individual consumers might filter what they process, but that's not part of the fanout pattern itself."
                }
            },
            // Continue Domain 1: Development
            {
                id: 6,
                domain: "Development",
                type: "Multiple Choice",
                question: "A developer is using Amazon DynamoDB and needs to query items based on attributes other than the primary key. What should the developer create?",
                options: [
                    { text: "A Global Secondary Index (GSI)", correct: true },
                    { text: "A Local Secondary Index (LSI)", correct: false },
                    { text: "A materialized view", correct: false },
                    { text: "A read replica", correct: false }
                ],
                materials: "DynamoDB Indexes - Querying Beyond Primary Keys:\n\nDynamoDB Core Concept:\n‚Ä¢ Tables have a Primary Key (Partition Key + optional Sort Key)\n‚Ä¢ By default, you can ONLY query using the primary key\n‚Ä¢ For other attributes? You need Secondary Indexes\n\nTwo Types of Secondary Indexes:\n\n1. Global Secondary Index (GSI):\n‚úì Can use ANY attributes as partition/sort keys\n‚úì Different keys than base table\n‚úì Spans all partitions (\"global\")\n‚úì Eventually consistent by default\n‚úì Has its own throughput (separate RCU/WCU)\n‚úì Can be created/deleted after table creation\n‚úì Limit: 20 GSIs per table\n\nExample:\nBase Table: userId (PK), email, country, age\nGSI: country (PK), age (SK)\nNow you can: Query users by country and age!\n\n2. Local Secondary Index (LSI):\n‚úì MUST use same partition key as base table\n‚úì Different sort key only\n‚úì Shares throughput with base table\n‚úì Can be strongly consistent\n‚úì MUST be created at table creation (can't add later)\n‚úì Limit: 5 LSIs per table\n\nExample:\nBase Table: userId (PK), timestamp (SK)\nLSI: userId (PK), status (SK)\nNow you can: Query user's items by status\n\nWhen to Use Which:\n\n‚Ä¢ Need different partition key? ‚Üí GSI\n‚Ä¢ Need to query by non-primary attributes? ‚Üí GSI\n‚Ä¢ Need strong consistency? ‚Üí LSI\n‚Ä¢ Already have the right partition key? ‚Üí LSI\n‚Ä¢ Creating new table? ‚Üí Can use both\n‚Ä¢ Existing table? ‚Üí Only GSI\n\nImportant Considerations:\n\n1. Projections (what attributes are copied to index):\n   ‚Ä¢ KEYS_ONLY: Just the keys (smallest, cheapest)\n   ‚Ä¢ INCLUDE: Keys + specific attributes\n   ‚Ä¢ ALL: All attributes (largest, most expensive)\n\n2. Cost Impact:\n   ‚Ä¢ Indexes consume storage (data duplication)\n   ‚Ä¢ GSIs have separate throughput charges\n   ‚Ä¢ More indexes = higher costs\n\n3. Performance:\n   ‚Ä¢ Queries on indexes are fast (like primary key queries)\n   ‚Ä¢ Scans on indexes still scan everything (slow)\n\nCommon Mistake:\n‚ùå Creating too many GSIs (costs add up)\n‚ùå Projecting ALL attributes when not needed\n‚ùå Using Scan instead of Query even with indexes\n\nBest Practices:\n‚úì Design primary key to support main access pattern\n‚úì Use GSIs for additional access patterns\n‚úì Project only needed attributes\n‚úì Monitor GSI throughput separately\n\nExam Tip: GSI = Global = Different partition key = Flexible",
                explanations: {
                    "A Global Secondary Index (GSI)": "Correct! GSIs allow querying on non-primary key attributes with different partition and sort keys.",
                    "A Local Secondary Index (LSI)": "Incorrect. LSIs must use the same partition key as the base table, only the sort key can differ.",
                    "A materialized view": "Incorrect. DynamoDB doesn't have materialized views.",
                    "A read replica": "Incorrect. DynamoDB uses global tables for replication, not read replicas."
                }
            },
            {
                id: 7,
                domain: "Development",
                type: "Multiple Response",
                question: "A Lambda function needs access to secrets stored in AWS Secrets Manager. Which actions are required? (Select TWO)",
                options: [
                    { text: "Grant the Lambda execution role permissions to access Secrets Manager", correct: true },
                    { text: "Store the secret ARN in an environment variable", correct: false },
                    { text: "Use the AWS SDK to retrieve the secret at runtime", correct: true },
                    { text: "Enable VPC endpoints for Secrets Manager", correct: false },
                    { text: "Encrypt the Lambda function code", correct: false }
                ],
                materials: "Lambda + Secrets Manager Integration:\n\nThe Problem:\nYour Lambda function needs sensitive data (database passwords, API keys, tokens). Where do you store them securely?\n\n‚ùå BAD Approaches:\n‚Ä¢ Hardcoding in code (anyone with code access sees secrets)\n‚Ä¢ Environment variables (better, but still visible in console)\n‚Ä¢ Storing in S3 (manual encryption management)\n\n‚úì BEST Approach: AWS Secrets Manager\n\nWhy Secrets Manager?\n‚úì Encrypted storage (KMS encryption)\n‚úì Automatic rotation of secrets\n‚úì Versioning and audit trails\n‚úì Fine-grained access control\n‚úì No secrets in code or environment\n\nHow to Implement (2 Required Steps):\n\n1. Grant IAM Permissions:\nAdd to Lambda execution role:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": [\n    \"secretsmanager:GetSecretValue\"\n  ],\n  \"Resource\": \"arn:aws:secretsmanager:region:account:secret:name\"\n}\n```\n\n2. Retrieve Secret in Code:\n```python\nimport boto3\nimport json\n\ndef lambda_handler(event, context):\n    client = boto3.client('secretsmanager')\n    \n    response = client.get_secret_value(\n        SecretId='prod/db/password'\n    )\n    \n    secret = json.loads(response['SecretString'])\n    db_password = secret['password']\n    \n    # Use the secret\n    # ...\n```\n\nOptional Best Practices:\n\n1. Store Secret ARN in Environment Variable:\n   ‚Ä¢ Makes code reusable across environments\n   ‚Ä¢ Easy to change without code changes\n   ‚Ä¢ Still secure (ARN is not the secret)\n\n2. Cache Secrets:\n   ‚Ä¢ Don't fetch on every invocation\n   ‚Ä¢ Store in global scope (outside handler)\n   ‚Ä¢ Reduces API calls and costs\n   ‚Ä¢ Reduces latency\n\n3. Use VPC Endpoints (if Lambda in VPC):\n   ‚Ä¢ Lambda in VPC without NAT can't reach internet\n   ‚Ä¢ VPC endpoint allows private connection to Secrets Manager\n   ‚Ä¢ No extra charge for Secrets Manager endpoint\n\nCaching Example:\n```python\nimport boto3\nimport json\n\n# Global scope - persists across invocations\nclient = boto3.client('secretsmanager')\ncached_secret = None\n\ndef lambda_handler(event, context):\n    global cached_secret\n    \n    if cached_secret is None:\n        response = client.get_secret_value(\n            SecretId='prod/db/password'\n        )\n        cached_secret = json.loads(response['SecretString'])\n    \n    # Use cached_secret\n    db_password = cached_secret['password']\n```\n\nCommon Mistakes:\n‚ùå Forgetting IAM permissions (Lambda gets AccessDenied)\n‚ùå Not handling SecretString vs SecretBinary\n‚ùå Fetching secret on every invocation (slow + costly)\n‚ùå Not using VPC endpoints when Lambda is in VPC\n\nCost Considerations:\n‚Ä¢ $0.40 per secret per month\n‚Ä¢ $0.05 per 10,000 API calls\n‚Ä¢ Caching reduces API call costs\n\nExam Tip: Two things always needed: IAM permissions + SDK call",
                explanations: {
                    "Grant the Lambda execution role permissions to access Secrets Manager": "Correct! The execution role needs secretsmanager:GetSecretValue permission.",
                    "Store the secret ARN in an environment variable": "Partially correct practice but not required. The ARN can be hardcoded or from config.",
                    "Use the AWS SDK to retrieve the secret at runtime": "Correct! Use AWS SDK's SecretsManager client to call GetSecretValue.",
                    "Enable VPC endpoints for Secrets Manager": "Incorrect. Only needed if Lambda is in a VPC without internet access.",
                    "Encrypt the Lambda function code": "Incorrect. This doesn't relate to accessing Secrets Manager."
                }
            },
            {
                id: 8,
                domain: "Development",
                type: "Multiple Choice",
                question: "What is the maximum execution time for an AWS Lambda function?",
                options: [
                    { text: "3 minutes", correct: false },
                    { text: "5 minutes", correct: false },
                    { text: "15 minutes", correct: true },
                    { text: "30 minutes", correct: false }
                ],
                materials: "AWS Lambda Limits and Constraints:\n\nExecution Time Limit: 15 Minutes (900 seconds)\n\nHistory of the Limit:\n‚Ä¢ Originally: 5 minutes (300 seconds)\n‚Ä¢ AWS increased it to 15 minutes\n‚Ä¢ This is the MAXIMUM you can configure\n‚Ä¢ You set timeout anywhere from 1 second to 900 seconds\n\nWhy the 15-Minute Limit Exists:\nLambda is designed for short-lived, event-driven tasks. For longer processes, AWS recommends:\n‚Ä¢ EC2 or ECS for long-running tasks\n‚Ä¢ Step Functions to chain multiple Lambda functions\n‚Ä¢ Batch processing services\n\nOther Important Lambda Limits:\n\n1. Memory:\n   ‚Ä¢ Minimum: 128 MB\n   ‚Ä¢ Maximum: 10,240 MB (10 GB)\n   ‚Ä¢ Allocated in 1 MB increments\n   ‚Ä¢ CPU scales with memory (more memory = more CPU)\n\n2. Deployment Package Size:\n   ‚Ä¢ Zipped: 50 MB (direct upload)\n   ‚Ä¢ Unzipped: 250 MB (including layers)\n   ‚Ä¢ Using S3: 50 MB zipped display, 250 MB unzipped\n\n3. Environment Variables:\n   ‚Ä¢ Maximum: 4 KB total\n   ‚Ä¢ All variables combined\n\n4. /tmp Storage:\n   ‚Ä¢ 512 MB to 10 GB (configurable)\n   ‚Ä¢ Ephemeral (cleared after execution)\n   ‚Ä¢ Shared across invocations in same container\n\n5. Invocation Payload:\n   ‚Ä¢ Synchronous: 6 MB (request & response)\n   ‚Ä¢ Asynchronous: 256 KB\n\n6. Concurrent Executions:\n   ‚Ä¢ Default account limit: 1,000\n   ‚Ä¢ Can request increase\n   ‚Ä¢ Reserved concurrency can be set per function\n\n7. File Descriptors:\n   ‚Ä¢ 1,024 open file descriptors\n\nWhen You Hit the 15-Minute Limit:\n\nOption 1: Break into Smaller Functions\n```\n[Lambda 1] ‚Üí Process batch 1 ‚Üí [SQS/SNS]\n[Lambda 2] ‚Üí Process batch 2 ‚Üí [SQS/SNS]\n[Lambda 3] ‚Üí Process batch 3 ‚Üí [SQS/SNS]\n```\n\nOption 2: Use Step Functions\n```\nStep Functions orchestrates:\n‚îú‚Üí Lambda 1 (15 min)\n‚îú‚Üí Lambda 2 (15 min)\n‚îî‚Üí Lambda 3 (15 min)\nTotal: 45 minutes of processing!\n```\n\nOption 3: Switch to ECS/Fargate\n‚Ä¢ For truly long-running tasks\n‚Ä¢ No time limits\n‚Ä¢ Better for batch processing\n\nOption 4: Use AWS Batch\n‚Ä¢ Designed for batch computing\n‚Ä¢ Can run for hours/days\n\nCommon Patterns:\n\n‚Ä¢ Data Processing: Process in chunks, use S3 triggers\n‚Ä¢ Video Encoding: Break into segments\n‚Ä¢ Report Generation: Generate sections separately\n‚Ä¢ ETL Jobs: Use Glue or EMR for large datasets\n\nBest Practices:\n\n‚úì Set timeout slightly longer than expected duration\n‚úì Handle timeouts gracefully in code\n‚úì Use CloudWatch to monitor duration\n‚úì Design functions to complete well under 15 minutes\n‚úì Use Step Functions for multi-stage workflows\n\nExam Tips:\n‚Ä¢ Remember: 15 minutes = 900 seconds\n‚Ä¢ Lambda is NOT for long-running tasks\n‚Ä¢ For > 15 min, think: Step Functions, ECS, or Batch\n‚Ä¢ Default timeout is often 3 seconds (configure it!)\n\nMonitoring Timeouts:\n‚Ä¢ CloudWatch Metric: Duration\n‚Ä¢ Set alarms for functions approaching timeout\n‚Ä¢ Look for pattern: many invocations at exactly timeout value",
                explanations: {
                    "3 minutes": "Incorrect. This was an old limit from earlier Lambda versions.",
                    "5 minutes": "Incorrect. This is less than the current maximum.",
                    "15 minutes": "Correct! Lambda functions can run for a maximum of 900 seconds (15 minutes).",
                    "30 minutes": "Incorrect. This exceeds Lambda's maximum execution time."
                }
            },
            {
                id: 9,
                domain: "Development",
                type: "Multiple Choice",
                question: "A developer wants to enable versioning for a Lambda function. What happens when a new version is published?",
                options: [
                    { text: "The $LATEST version is automatically updated", correct: false },
                    { text: "A new immutable version is created with an incremented number", correct: true },
                    { text: "All previous versions are deleted", correct: false },
                    { text: "The function code is compressed", correct: false }
                ],
                materials: "Lambda Versioning - Immutable Deployments:\n\nThe Challenge:\nYou update your Lambda code. Something breaks. How do you roll back? How do you test new code while keeping prod stable?\n\nSolution: Lambda Versioning\n\nKey Concepts:\n\n1. $LATEST (The Mutable Version):\n   ‚Ä¢ Always exists\n   ‚Ä¢ Points to the most recent code you uploaded\n   ‚Ä¢ Mutable (can be changed)\n   ‚Ä¢ Used for development/testing\n   ‚Ä¢ When you update code, $LATEST changes\n\n2. Published Versions (Immutable):\n   ‚Ä¢ Created when you \"publish\" $LATEST\n   ‚Ä¢ Given incremental numbers: v1, v2, v3, etc.\n   ‚Ä¢ Immutable (cannot be changed EVER)\n   ‚Ä¢ Each has its own ARN\n   ‚Ä¢ Includes code + configuration snapshot\n\nHow Versioning Works:\n\n```\n1. Upload new code ‚Üí Updates $LATEST\n2. Test $LATEST\n3. Publish version ‚Üí Creates v1 (immutable)\n4. Upload more changes ‚Üí Updates $LATEST\n5. Publish version ‚Üí Creates v2 (immutable)\n6. v1 still exists unchanged\n```\n\nVersion ARN Format:\n```\narn:aws:lambda:region:account:function:myFunction:1\narn:aws:lambda:region:account:function:myFunction:2\narn:aws:lambda:region:account:function:myFunction:$LATEST\n```\n\nWhy Use Versioning?\n\n‚úì Safe Deployments:\n  ‚Ä¢ Test new code as $LATEST\n  ‚Ä¢ Publish when ready\n  ‚Ä¢ Production keeps using old version\n\n‚úì Easy Rollback:\n  ‚Ä¢ Problem with v2?\n  ‚Ä¢ Switch back to v1 instantly\n  ‚Ä¢ No redeployment needed\n\n‚úì Traffic Shifting:\n  ‚Ä¢ Route 90% traffic to v1\n  ‚Ä¢ Route 10% traffic to v2 (canary)\n  ‚Ä¢ Gradually shift to 100% v2\n\n‚úì Environment Separation:\n  ‚Ä¢ Dev environment uses $LATEST\n  ‚Ä¢ Staging uses v2\n  ‚Ä¢ Production uses v1\n\nAliases (Work with Versions):\n\nAn alias is a pointer to a version:\n```\nPROD alias ‚Üí points to v1\nSTAGING alias ‚Üí points to v2\nDEV alias ‚Üí points to $LATEST\n```\n\nBenefits:\n‚Ä¢ Change what version alias points to\n‚Ä¢ API Gateway/triggers use alias (stable endpoint)\n‚Ä¢ Update alias, not all triggers\n\nAlias Weighted Routing:\n```\nPROD alias:\n‚îú‚Üí 90% traffic to v1\n‚îî‚Üí 10% traffic to v2\n```\n\nDeployment Strategies:\n\n1. All-at-Once:\n```\nPROD alias: v1 ‚Üí Update to v2\n```\n\n2. Canary:\n```\nPROD alias:\n‚îú‚Üí 95% to v1 (stable)\n‚îî‚Üí 5% to v2 (test)\nIf good:\n‚îî‚Üí 100% to v2\n```\n\n3. Linear:\n```\nShift 10% every 10 minutes:\n10% ‚Üí 20% ‚Üí 30% ... ‚Üí 100%\n```\n\nCodeDeploy Integration:\n‚Ä¢ Automates canary and linear deployments\n‚Ä¢ CloudWatch alarms can trigger rollback\n‚Ä¢ Predefined deployment configs\n\nCommon Patterns:\n\n```\n[API Gateway]\n    ‚Üì\n[PROD Alias] ‚Üí v1 (stable)\n[STAGING Alias] ‚Üí v2 (testing)\n[DEV Alias] ‚Üí $LATEST (active development)\n```\n\nVersion Management:\n\n‚Ä¢ Versions are never deleted automatically\n‚Ä¢ Old versions consume storage (costs)\n‚Ä¢ Clean up old versions periodically\n‚Ä¢ Keep recent versions for rollback\n\nImportant Notes:\n\n‚úì Each version has separate:\n  ‚Ä¢ Code snapshot\n  ‚Ä¢ Configuration (memory, timeout, env vars)\n  ‚Ä¢ Dependencies/layers\n\n‚úì Versions can have different:\n  ‚Ä¢ IAM roles\n  ‚Ä¢ VPC settings\n  ‚Ä¢ Environment variables\n\n‚úì But versions share:\n  ‚Ä¢ Concurrency limits (unless reserved)\n  ‚Ä¢ CloudWatch log groups\n\nExam Tips:\n‚Ä¢ Published versions = Immutable\n‚Ä¢ $LATEST = Mutable\n‚Ä¢ Use aliases for stable endpoints\n‚Ä¢ CodeDeploy for automated traffic shifting\n‚Ä¢ Versions enable blue/green deployments",
                explanations: {
                    "The $LATEST version is automatically updated": "Incorrect. $LATEST is mutable and points to the latest unpublished changes.",
                    "A new immutable version is created with an incremented number": "Correct! Each published version gets an incremented number (1, 2, 3...) and cannot be changed.",
                    "All previous versions are deleted": "Incorrect. Previous versions remain available unless explicitly deleted.",
                    "The function code is compressed": "Incorrect. This isn't related to versioning."
                }
            },
            {
                id: 10,
                domain: "Development",
                type: "Multiple Choice",
                question: "Which AWS service should be used to implement a publish/subscribe messaging pattern?",
                options: [
                    { text: "Amazon SQS", correct: false },
                    { text: "Amazon SNS", correct: true },
                    { text: "Amazon Kinesis", correct: false },
                    { text: "AWS Step Functions", correct: false }
                ],
                materials: "AWS Messaging Services - Pub/Sub Pattern:\n\nPub/Sub = Publish/Subscribe Pattern\n\nOne message published ‚Üí Multiple subscribers receive it\n\nThe Problem It Solves:\nYou want to send a notification/event to multiple independent consumers:\n‚Ä¢ Send order confirmation to email service\n‚Ä¢ Send to SMS service\n‚Ä¢ Send to analytics service\n‚Ä¢ Send to audit log\n\nWithout Pub/Sub (BAD):\n```\nOrderService calls:\n‚îú‚Üí EmailService\n‚îú‚Üí SMSService\n‚îú‚Üí AnalyticsService\n‚îî‚Üí AuditService\n\nProblems:\n‚Ä¢ Tight coupling\n‚Ä¢ OrderService knows all consumers\n‚Ä¢ If one fails, need error handling\n‚Ä¢ Adding new consumer = code changes\n```\n\nWith Pub/Sub (GOOD):\n```\nOrderService ‚Üí Publishes to SNS Topic\n                      ‚Üì\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n        ‚Üì             ‚Üì             ‚Üì\n  EmailService  SMSService  AnalyticsService\n```\n\nAWS SNS (Simple Notification Service):\n\n‚úì Perfect for Pub/Sub pattern\n‚úì One message ‚Üí many subscribers\n‚úì Push-based (actively delivers)\n‚úì Multiple protocol support\n‚úì Immediate delivery\n‚úì No polling needed\n\nSNS Subscription Types:\n‚Ä¢ HTTP/HTTPS endpoints\n‚Ä¢ Email/Email-JSON\n‚Ä¢ SMS\n‚Ä¢ SQS queues\n‚Ä¢ Lambda functions\n‚Ä¢ Mobile push notifications\n‚Ä¢ Kinesis Data Firehose\n\nHow It Works:\n\n1. Create SNS Topic: \"order-created\"\n2. Services subscribe to topic\n3. OrderService publishes message\n4. SNS delivers to all subscribers\n\nMessage Flow:\n```\nPublisher ‚Üí SNS Topic ‚Üí Fan Out ‚Üí Subscribers\n                                   (all receive)\n```\n\nSNS Features:\n\n‚Ä¢ Message Filtering:\n  Subscribers can filter messages by attributes\n  ```\n  Subscription filter: {\"order_type\": [\"premium\"]}\n  Only receives premium order notifications\n  ```\n\n‚Ä¢ Message Attributes:\n  Add metadata to messages\n  ```\n  {\"order_type\": \"premium\", \"region\": \"us-east\"}\n  ```\n\n‚Ä¢ Dead Letter Queues:\n  Failed deliveries go to DLQ for debugging\n\n‚Ä¢ Retry Logic:\n  Automatic retries for failed deliveries\n\n‚Ä¢ FIFO Topics:\n  Ordered delivery and deduplication\n\nComparing AWS Messaging Services:\n\n1. SNS (Pub/Sub):\n   ‚Ä¢ One-to-many\n   ‚Ä¢ Push-based\n   ‚Ä¢ Multiple subscribers\n   ‚Ä¢ Real-time delivery\n   ‚Ä¢ Use for: Fanout, notifications, events\n\n2. SQS (Queue):\n   ‚Ä¢ Point-to-point\n   ‚Ä¢ Pull-based (consumers poll)\n   ‚Ä¢ One consumer per message\n   ‚Ä¢ Decoupling\n   ‚Ä¢ Use for: Job queues, buffering, decoupling\n\n3. Kinesis (Streaming):\n   ‚Ä¢ Real-time data streaming\n   ‚Ä¢ Multiple consumers (each reads all data)\n   ‚Ä¢ Ordered within shard\n   ‚Ä¢ Data replay capability\n   ‚Ä¢ Use for: Big data, analytics, logs\n\n4. EventBridge (Event Bus):\n   ‚Ä¢ Advanced event routing\n   ‚Ä¢ Schema registry\n   ‚Ä¢ Integration with 90+ AWS services\n   ‚Ä¢ Use for: Event-driven architectures, integrations\n\n5. Step Functions (Orchestration):\n   ‚Ä¢ Workflow coordination\n   ‚Ä¢ State management\n   ‚Ä¢ Not messaging, but coordination\n   ‚Ä¢ Use for: Multi-step processes\n\nCommon Pattern: SNS + SQS Fan-Out:\n\n```\nSNS Topic\n    ‚îú‚Üí SQS Queue 1 ‚Üí Service A\n    ‚îú‚Üí SQS Queue 2 ‚Üí Service B\n    ‚îî‚Üí SQS Queue 3 ‚Üí Service C\n\nBenefits:\n‚Ä¢ SNS fans out to multiple queues\n‚Ä¢ Each service processes at own pace\n‚Ä¢ Reliable delivery (SQS guarantees)\n‚Ä¢ Decoupled processing\n```\n\nReal-World Use Cases:\n\nSNS Perfect For:\n‚Ä¢ Sending notifications (email, SMS, push)\n‚Ä¢ Broadcasting events to multiple systems\n‚Ä¢ Mobile app notifications\n‚Ä¢ Triggering multiple Lambda functions\n‚Ä¢ Alerting/monitoring systems\n\nExam Scenarios:\n\n Q: \"One event needs to trigger multiple actions\"\n A: SNS\n\n Q: \"Send notifications to mobile and email\"\n A: SNS\n\n Q: \"Multiple services need to process same order\"\n A: SNS (fan-out pattern)\n\n Q: \"Decouple two services with queuing\"\n A: SQS\n\n Q: \"Process streaming clickstream data\"\n A: Kinesis\n\nKey Exam Tip:\n‚Ä¢ Pub/Sub pattern = SNS\n‚Ä¢ Queuing pattern = SQS\n‚Ä¢ Streaming data = Kinesis\n‚Ä¢ Complex routing/integration = EventBridge",
                explanations: {
                    "Amazon SQS": "Incorrect. SQS is a queue service, not pub/sub. One consumer reads each message.",
                    "Amazon SNS": "Correct! SNS is designed for pub/sub patterns, allowing one message to be delivered to multiple subscribers.",
                    "Amazon Kinesis": "Incorrect. Kinesis is for real-time data streaming, not simple pub/sub messaging.",
                    "AWS Step Functions": "Incorrect. Step Functions orchestrate workflows, not messaging."
                }
            },
            {
                id: 11,
                domain: "Development",
                type: "Multiple Choice",
                question: "A developer needs to store large objects up to 5 TB. Which storage solution should be used?",
                options: [
                    { text: "Amazon EBS", correct: false },
                    { text: "Amazon S3", correct: true },
                    { text: "Amazon EFS", correct: false },
                    { text: "Amazon DynamoDB", correct: false }
                ],
                materials: "AWS Storage Services - Size Limits and Use Cases:\n\nThe Question: Need to store individual objects up to 5 TB\n\nAmazon S3 (Simple Storage Service):\n‚úì Maximum object size: 5 TB\n‚úì Object storage (files, images, videos, backups)\n‚úì Virtually unlimited storage\n‚úì 99.999999999% (11 9's) durability\n‚úì Pay per GB stored\n‚úì Perfect for large files\n\nUpload Methods:\n‚Ä¢ Single PUT: Up to 5 GB\n‚Ä¢ Multipart Upload: 5 GB to 5 TB (required for > 5 GB)\n\nS3 Use Cases:\n‚Ä¢ Backups and archives\n‚Ä¢ Media files (videos, images)\n‚Ä¢ Data lakes\n‚Ä¢ Static website hosting\n‚Ä¢ Application artifacts\n\nComparing Other Storage Services:\n\n1. Amazon EBS (Elastic Block Store):\n   ‚Ä¢ Maximum volume size: 64 TB (per volume)\n   ‚Ä¢ BUT: Block storage for EC2 instances\n   ‚Ä¢ Must attach to EC2\n   ‚Ä¢ Not for standalone object storage\n   ‚Ä¢ Use case: Database storage, EC2 root volumes\n\n2. Amazon EFS (Elastic File System):\n   ‚Ä¢ Virtually unlimited size (petabytes)\n   ‚Ä¢ File system (NFS protocol)\n   ‚Ä¢ Multiple EC2 instances can mount\n   ‚Ä¢ More expensive than S3\n   ‚Ä¢ Use case: Shared file system, content management\n\n3. Amazon DynamoDB:\n   ‚Ä¢ Maximum item size: 400 KB\n   ‚Ä¢ ‚ùå Way too small for large objects\n   ‚Ä¢ NoSQL database, not file storage\n   ‚Ä¢ Use case: Structured data, key-value pairs\n\n4. Amazon FSx:\n   ‚Ä¢ Windows: 64 TB per file system\n   ‚Ä¢ Lustre: Unlimited\n   ‚Ä¢ Managed file systems (Windows, Lustre, NetApp)\n   ‚Ä¢ Use case: Windows workloads, HPC\n\n5. Instance Store:\n   ‚Ä¢ Varies by instance type\n   ‚Ä¢ Ephemeral (data lost on stop)\n   ‚Ä¢ Use case: Temporary data, cache\n\nWhen to Use What:\n\n```\nNeed to store large files (up to 5 TB)?\n‚îî‚Üí S3 ‚úì\n\nNeed block storage for EC2?\n‚îî‚Üí EBS ‚úì\n\nNeed shared file system for multiple EC2s?\n‚îî‚Üí EFS or FSx ‚úì\n\nNeed database storage?\n‚îî‚Üí RDS with EBS or DynamoDB ‚úì\n\nNeed temporary high-performance storage?\n‚îî‚Üí Instance Store ‚úì\n```\n\nS3 Object Size Best Practices:\n\n‚Ä¢ Objects < 100 MB: Single PUT\n‚Ä¢ Objects 100 MB - 5 GB: Consider multipart\n‚Ä¢ Objects > 5 GB: MUST use multipart upload\n\nMultipart Upload Benefits:\n‚Ä¢ Upload parts in parallel (faster)\n‚Ä¢ Resume failed uploads\n‚Ä¢ Upload while creating the file\n‚Ä¢ Improve throughput\n\nMultipart Upload Process:\n```\n1. Initiate multipart upload\n2. Upload parts (5 MB - 5 GB each)\n3. Parts can be uploaded in parallel\n4. Complete multipart upload\n5. S3 assembles the object\n```\n\nS3 Storage Classes (all support 5 TB objects):\n‚Ä¢ S3 Standard: Frequent access\n‚Ä¢ S3 Intelligent-Tiering: Unknown access patterns\n‚Ä¢ S3 Standard-IA: Infrequent access\n‚Ä¢ S3 One Zone-IA: Infrequent, single AZ\n‚Ä¢ S3 Glacier Instant: Archive with instant retrieval\n‚Ä¢ S3 Glacier Flexible: Archive with configurable retrieval\n‚Ä¢ S3 Glacier Deep Archive: Long-term archive\n\nCost Comparison (per GB/month):\n‚Ä¢ S3 Standard: ~$0.023\n‚Ä¢ EFS: ~$0.30 (13x more expensive)\n‚Ä¢ EBS: ~$0.10 (4x more expensive)\n\nExam Tips:\n‚Ä¢ 5 TB object storage ‚Üí S3\n‚Ä¢ EBS is block storage for EC2, not object storage\n‚Ä¢ DynamoDB max item size is only 400 KB\n‚Ä¢ Multipart upload required for objects > 5 GB",
                explanations: {
                    "Amazon EBS": "Incorrect. EBS volumes have smaller size limits and are block storage for EC2.",
                    "Amazon S3": "Correct! S3 supports objects up to 5 TB and is designed for large object storage.",
                    "Amazon EFS": "Incorrect. EFS is a file system, not optimized for individual large objects.",
                    "Amazon DynamoDB": "Incorrect. DynamoDB has a 400 KB item size limit."
                }
            },
            {
                id: 12,
                domain: "Development",
                type: "Multiple Response",
                question: "Which DynamoDB operations consume read capacity units? (Select TWO)",
                options: [
                    { text: "GetItem", correct: true },
                    { text: "PutItem", correct: false },
                    { text: "Query", correct: true },
                    { text: "UpdateItem", correct: false },
                    { text: "DeleteItem", correct: false }
                ],
                materials: "DynamoDB Capacity Units - Read vs Write:\n\nDynamoDB Capacity Model:\n‚Ä¢ Read Capacity Units (RCU) - for read operations\n‚Ä¢ Write Capacity Units (WCU) - for write operations\n\nREAD Operations (Consume RCUs):\n\n1. GetItem:\n   ‚úì Retrieves a single item by primary key\n   ‚úì Consumes RCUs\n   ‚úì 1 RCU = 1 strongly consistent read of 4 KB\n   ‚úì 1 RCU = 2 eventually consistent reads of 4 KB\n\n2. Query:\n   ‚úì Retrieves multiple items using primary key\n   ‚úì Consumes RCUs based on data size returned\n   ‚úì More efficient than Scan\n\n3. Scan:\n   ‚úì Reads entire table or index\n   ‚úì Consumes RCUs for all items examined\n   ‚úì Most expensive operation\n\n4. BatchGetItem:\n   ‚úì Retrieves up to 100 items (max 16 MB)\n   ‚úì Consumes RCUs based on items retrieved\n\nWRITE Operations (Consume WCUs):\n\n1. PutItem:\n   ‚úì Creates or replaces an item\n   ‚úì Consumes WCUs\n   ‚úì 1 WCU = 1 write of 1 KB\n\n2. UpdateItem:\n   ‚úì Modifies existing item attributes\n   ‚úì Consumes WCUs\n\n3. DeleteItem:\n   ‚úì Removes an item\n   ‚úì Consumes WCUs\n\n4. BatchWriteItem:\n   ‚úì Up to 25 put/delete operations\n   ‚úì Consumes WCUs for each write\n\nCapacity Unit Calculation:\n\nRead Capacity Units:\n```\nStrong Consistency:\n- Item size: 8 KB\n- RCU needed: 8 KB / 4 KB = 2 RCUs\n\nEventual Consistency (default):\n- Item size: 8 KB\n- RCU needed: 8 KB / 4 KB / 2 = 1 RCU\n```\n\nWrite Capacity Units:\n```\n- Item size: 3.5 KB\n- WCU needed: Round up (3.5 / 1) = 4 WCUs\n- Always round up to nearest KB\n```\n\nExample Calculations:\n\n1. Read 10 items of 6 KB each (strong):\n   ‚Ä¢ 6 KB √∑ 4 KB = 1.5 ‚Üí 2 RCUs per item\n   ‚Ä¢ 10 items √ó 2 = 20 RCUs total\n\n2. Read 10 items of 6 KB each (eventual):\n   ‚Ä¢ 6 KB √∑ 4 KB = 1.5 ‚Üí 2 RCUs (strong)\n   ‚Ä¢ 2 √∑ 2 = 1 RCU per item (eventual)\n   ‚Ä¢ 10 items √ó 1 = 10 RCUs total\n\n3. Write 5 items of 2.5 KB each:\n   ‚Ä¢ 2.5 KB ‚Üí rounds to 3 KB\n   ‚Ä¢ 3 KB √∑ 1 KB = 3 WCUs per item\n   ‚Ä¢ 5 items √ó 3 = 15 WCUs total\n\nCapacity Modes:\n\n1. Provisioned:\n   ‚Ä¢ Specify RCUs and WCUs\n   ‚Ä¢ Pay for provisioned capacity\n   ‚Ä¢ Can use auto-scaling\n   ‚Ä¢ Cost-effective for predictable traffic\n\n2. On-Demand:\n   ‚Ä¢ Pay per request\n   ‚Ä¢ No capacity planning\n   ‚Ä¢ Auto-scales instantly\n   ‚Ä¢ Good for unpredictable traffic\n\nQuery vs Scan:\n\n```\nQuery (efficient):\n‚Ä¢ Uses primary key or index\n‚Ä¢ Reads only matched items\n‚Ä¢ Consumes RCUs for returned data\n‚Ä¢ Example: Get all orders for user_id=123\n\nScan (expensive):\n‚Ä¢ Examines every item in table\n‚Ä¢ Consumes RCUs for ALL items scanned\n‚Ä¢ Even if filter excludes them later\n‚Ä¢ Example: Find all items where status=\"active\"\n```\n\nOptimization Tips:\n\n‚úì Use eventual consistency when possible (half the RCUs)\n‚úì Use Query instead of Scan\n‚úì Use Scan with filters only when necessary\n‚úì Enable auto-scaling for provisioned mode\n‚úì Use projection expressions to fetch only needed attributes\n‚úì Use BatchGetItem for multiple items\n‚úì Monitor CloudWatch metrics for throttling\n\nCost Impact:\n‚Ä¢ 1 RCU costs ~$0.00013 per hour (provisioned)\n‚Ä¢ 1 WCU costs ~$0.00065 per hour (provisioned)\n‚Ä¢ WCUs cost 5x more than RCUs\n‚Ä¢ On-demand: $1.25 per million read requests\n‚Ä¢ On-demand: $1.25 per million write requests\n\nCommon Mistakes:\n‚ùå Using Scan when Query would work\n‚ùå Not considering item size in capacity planning\n‚ùå Fetching all attributes when only few are needed\n‚ùå Not using eventual consistency for non-critical reads\n\nExam Tip:\n‚Ä¢ Read operations: GetItem, Query, Scan, BatchGetItem\n‚Ä¢ Write operations: PutItem, UpdateItem, DeleteItem, BatchWriteItem\n‚Ä¢ Query consumes RCUs but is more efficient than Scan",
                explanations: {
                    "GetItem": "Correct! GetItem is a read operation that consumes read capacity units.",
                    "PutItem": "Incorrect. PutItem is a write operation consuming write capacity units.",
                    "Query": "Correct! Query reads multiple items and consumes read capacity units.",
                    "UpdateItem": "Incorrect. UpdateItem is a write operation.",
                    "DeleteItem": "Incorrect. DeleteItem is a write operation."
                }
            },
            {
                id: 13,
                domain: "Development",
                type: "Multiple Choice",
                question: "What is the purpose of AWS X-Ray in application development?",
                options: [
                    { text: "To encrypt data at rest", correct: false },
                    { text: "To trace and analyze distributed application requests", correct: true },
                    { text: "To manage application secrets", correct: false },
                    { text: "To deploy application code", correct: false }
                ],
                materials: "AWS X-Ray - Distributed Tracing & Analysis:\n\nThe Problem X-Ray Solves:\nYou have a microservices application:\n```\nAPI Gateway ‚Üí Lambda A ‚Üí DynamoDB\n              ‚Üì\n           Lambda B ‚Üí SQS ‚Üí Lambda C ‚Üí S3\n              ‚Üì\n           RDS\n```\n\nUser reports: \"The API is slow!\"\nWhich service is the bottleneck? Where is the error?\n\nWithout X-Ray: Check logs in 6 different places üò∞\nWith X-Ray: See the entire request flow in one place! üéØ\n\nWhat X-Ray Does:\n\n‚úì Traces requests across ALL services\n‚úì Shows service map (visual diagram)\n‚úì Identifies performance bottlenecks\n‚úì Finds errors and exceptions\n‚úì Analyzes latency distribution\n‚úì Provides detailed timing for each service call\n‚úì Correlates logs across services\n\nKey Concepts:\n\n1. Trace:\n   ‚Ä¢ End-to-end journey of a single request\n   ‚Ä¢ Shows all services the request touched\n   ‚Ä¢ Includes timing and status\n\n2. Segment:\n   ‚Ä¢ Data from a single service/component\n   ‚Ä¢ Example: Lambda function execution\n   ‚Ä¢ Contains timing, metadata, errors\n\n3. Subsegment:\n   ‚Ä¢ Granular details within a segment\n   ‚Ä¢ Example: DynamoDB call within Lambda\n   ‚Ä¢ Database queries, HTTP calls, etc.\n\n4. Service Map:\n   ‚Ä¢ Visual representation of architecture\n   ‚Ä¢ Shows how services connect\n   ‚Ä¢ Displays latency and error rates\n\n5. Annotations:\n   ‚Ä¢ Key-value pairs for indexing\n   ‚Ä¢ Searchable in X-Ray console\n   ‚Ä¢ Example: user_id, order_id\n\n6. Metadata:\n   ‚Ä¢ Additional debug information\n   ‚Ä¢ Not indexed\n   ‚Ä¢ Example: Full request/response bodies\n\nHow X-Ray Works:\n\n```\n1. Request arrives with/without X-Ray trace ID\n2. Each service:\n   - Receives trace ID\n   - Records segment (what it did, how long)\n   - Passes trace ID to downstream services\n3. All segments sent to X-Ray\n4. X-Ray assembles complete trace\n5. Displays in visual service map\n```\n\nEnabling X-Ray:\n\n1. Lambda:\n   ‚Ä¢ Enable Active Tracing in function configuration\n   ‚Ä¢ Add X-Ray SDK to code (for subsegments)\n   ‚Ä¢ Lambda runtime includes X-Ray daemon\n\n2. API Gateway:\n   ‚Ä¢ Enable X-Ray tracing on stage settings\n   ‚Ä¢ Automatically traces requests\n\n3. EC2/ECS:\n   ‚Ä¢ Install X-Ray daemon\n   ‚Ä¢ Use X-Ray SDK in application code\n   ‚Ä¢ Send segments to local daemon\n\n4. Elastic Beanstalk:\n   ‚Ä¢ Enable in .ebextensions config\n   ‚Ä¢ Daemon installed automatically\n\nX-Ray SDK Usage:\n\n```python\nimport aws_xray_sdk\nfrom aws_xray_sdk.core import xray_recorder\nfrom aws_xray_sdk.core import patch_all\n\n# Instrument AWS SDK calls\npatch_all()\n\ndef lambda_handler(event, context):\n    # Create subsegment for custom logic\n    with xray_recorder.capture('process_order'):\n        # Your code here\n        result = process_order(event)\n        \n        # Add annotations (searchable)\n        xray_recorder.put_annotation('order_id', event['orderId'])\n        xray_recorder.put_annotation('user_id', event['userId'])\n        \n        # Add metadata (debugging)\n        xray_recorder.put_metadata('order_details', event)\n        \n    return result\n```\n\nService Map Shows:\n‚Ä¢ Services (nodes) and connections (edges)\n‚Ä¢ Request counts\n‚Ä¢ Average latency\n‚Ä¢ Error rates\n‚Ä¢ Status (healthy/warning/error)\n\nExample Trace Timeline:\n```\nAPI Gateway (10ms)\n  ‚îî‚îÄ Lambda A (200ms)\n      ‚îú‚îÄ DynamoDB Query (50ms) ‚úì\n      ‚îú‚îÄ External API Call (100ms) ‚ö†Ô∏è SLOW\n      ‚îî‚îÄ S3 PutObject (30ms) ‚úì\n      \nTotal: 210ms\nBottleneck: External API (100ms)\n```\n\nX-Ray Insights:\n‚Ä¢ Identifies slow requests automatically\n‚Ä¢ Shows latency percentiles (p50, p95, p99)\n‚Ä¢ Detects anomalies\n‚Ä¢ Groups similar errors\n\nSampling:\n‚Ä¢ Don't trace every request (expensive)\n‚Ä¢ Default: First request/sec + 5% of additional\n‚Ä¢ Customizable sampling rules\n‚Ä¢ Balance cost vs visibility\n\nUse Cases:\n\n‚úì Debug production issues\n‚úì Identify performance bottlenecks\n‚úì Understand service dependencies\n‚úì Monitor microservices health\n‚úì Optimize slow endpoints\n‚úì Troubleshoot errors\n\nX-Ray vs Other Tools:\n\n‚Ä¢ CloudWatch Logs: Individual service logs\n‚Ä¢ X-Ray: Cross-service request tracing\n‚Ä¢ CloudWatch Metrics: Aggregated metrics\n‚Ä¢ X-Ray: Per-request details\n‚Ä¢ CloudWatch ServiceLens: Combines X-Ray + CloudWatch\n\nPermissions Needed:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": [\n    \"xray:PutTraceSegments\",\n    \"xray:PutTelemetryRecords\"\n  ],\n  \"Resource\": \"*\"\n}\n```\n\nCost:\n‚Ä¢ First 100,000 traces/month: FREE\n‚Ä¢ After that: $5 per 1 million traces recorded\n‚Ä¢ $0.50 per 1 million traces retrieved\n\nExam Tips:\n‚Ä¢ X-Ray = Distributed tracing\n‚Ä¢ Service map = Visual architecture\n‚Ä¢ Annotations = Searchable metadata\n‚Ä¢ Enable Active Tracing for Lambda\n‚Ä¢ Install daemon for EC2/ECS\n‚Ä¢ Not for encryption or deployment!",
                explanations: {
                    "To encrypt data at rest": "Incorrect. X-Ray is for tracing, not encryption. Use KMS for encryption.",
                    "To trace and analyze distributed application requests": "Correct! X-Ray provides distributed tracing to understand application behavior and performance.",
                    "To manage application secrets": "Incorrect. Use Secrets Manager or Parameter Store for secrets.",
                    "To deploy application code": "Incorrect. Use CodeDeploy, Elastic Beanstalk, or other deployment services."
                }
            },
            {
                id: 14,
                domain: "Development",
                type: "Multiple Choice",
                question: "A developer wants to invoke a Lambda function directly using the AWS CLI. Which command should be used?",
                options: [
                    { text: "aws lambda execute-function", correct: false },
                    { text: "aws lambda invoke", correct: true },
                    { text: "aws lambda run-function", correct: false },
                    { text: "aws lambda call", correct: false }
                ],
                materials: "AWS Lambda CLI Commands:\n\nInvoking Lambda Functions from CLI:\n\nThe Correct Command:\n```bash\naws lambda invoke \\\n  --function-name my-function \\\n  --payload '{\"key\": \"value\"}' \\\n  response.json\n```\n\nCommand Breakdown:\n‚Ä¢ aws lambda invoke - The correct command\n‚Ä¢ --function-name - Function name or ARN\n‚Ä¢ --payload - Input data (JSON string or file)\n‚Ä¢ response.json - Output file for response\n\nInvocation Types:\n\n1. Synchronous (Request-Response):\n```bash\naws lambda invoke \\\n  --function-name my-function \\\n  --invocation-type RequestResponse \\\n  --payload '{\"name\": \"test\"}' \\\n  response.json\n```\n‚Ä¢ Waits for function to complete\n‚Ä¢ Returns response immediately\n‚Ä¢ Default invocation type\n‚Ä¢ Max 6 MB payload\n‚Ä¢ Use for APIs, immediate results\n\n2. Asynchronous (Event):\n```bash\naws lambda invoke \\\n  --function-name my-function \\\n  --invocation-type Event \\\n  --payload '{\"task\": \"process\"}' \\\n  response.json\n```\n‚Ä¢ Returns immediately (202 accepted)\n‚Ä¢ Function runs in background\n‚Ä¢ Max 256 KB payload\n‚Ä¢ Use for background jobs\n‚Ä¢ Automatic retries on failure\n\n3. Dry Run:\n```bash\naws lambda invoke \\\n  --function-name my-function \\\n  --invocation-type DryRun \\\n  --payload '{\"test\": true}' \\\n  response.json\n```\n‚Ä¢ Validates permissions and parameters\n‚Ä¢ Doesn't actually run the function\n‚Ä¢ Use for testing IAM policies\n\nPayload Options:\n\nInline JSON:\n```bash\naws lambda invoke \\\n  --function-name my-function \\\n  --payload '{\"user\": \"john\", \"action\": \"login\"}' \\\n  response.json\n```\n\nFrom File:\n```bash\naws lambda invoke \\\n  --function-name my-function \\\n  --payload file://input.json \\\n  response.json\n```\n\nBase64 Encoded:\n```bash\naws lambda invoke \\\n  --function-name my-function \\\n  --payload $(echo '{\"test\":true}' | base64) \\\n  response.json\n```\n\nOther Essential Lambda CLI Commands:\n\n1. List Functions:\n```bash\naws lambda list-functions\n```\n\n2. Get Function Configuration:\n```bash\naws lambda get-function --function-name my-function\n```\n\n3. Create Function:\n```bash\naws lambda create-function \\\n  --function-name my-function \\\n  --runtime python3.9 \\\n  --role arn:aws:iam::123456789012:role/lambda-role \\\n  --handler index.handler \\\n  --zip-file fileb://function.zip\n```\n\n4. Update Function Code:\n```bash\naws lambda update-function-code \\\n  --function-name my-function \\\n  --zip-file fileb://new-code.zip\n```\n\n5. Update Function Configuration:\n```bash\naws lambda update-function-configuration \\\n  --function-name my-function \\\n  --timeout 30 \\\n  --memory-size 512\n```\n\n6. Delete Function:\n```bash\naws lambda delete-function --function-name my-function\n```\n\n7. Get Function Logs:\n```bash\naws logs tail /aws/lambda/my-function --follow\n```\n\n8. Publish Version:\n```bash\naws lambda publish-version --function-name my-function\n```\n\n9. Create Alias:\n```bash\naws lambda create-alias \\\n  --function-name my-function \\\n  --name PROD \\\n  --function-version 1\n```\n\n10. Add Permission:\n```bash\naws lambda add-permission \\\n  --function-name my-function \\\n  --statement-id s3-invoke \\\n  --action lambda:InvokeFunction \\\n  --principal s3.amazonaws.com\n```\n\nTesting & Debugging:\n\nTest with CloudWatch Logs:\n```bash\n# Invoke function\naws lambda invoke \\\n  --function-name my-function \\\n  --log-type Tail \\\n  --payload '{\"test\": true}' \\\n  response.json\n\n# Output includes last 4KB of logs in response\n```\n\nCheck Response:\n```bash\n# Invoke\naws lambda invoke \\\n  --function-name my-function \\\n  --payload '{\"name\": \"test\"}' \\\n  response.json\n\n# Read response\ncat response.json\n```\n\nError Handling:\n```bash\n# Check for errors\naws lambda invoke \\\n  --function-name my-function \\\n  --payload '{\"invalid\": \"data\"}' \\\n  response.json 2>&1\n\n# Response includes:\n# - StatusCode: 200 (success) or error code\n# - FunctionError: Unhandled (if error occurred)\n# - Error details in response.json\n```\n\nCommon Use Cases:\n\n1. Manual Testing:\n```bash\naws lambda invoke \\\n  --function-name dev-api-function \\\n  --payload '{\"httpMethod\": \"GET\", \"path\": \"/users\"}' \\\n  response.json && cat response.json\n```\n\n2. CI/CD Integration:\n```bash\n# Deploy and test\naws lambda update-function-code \\\n  --function-name my-function \\\n  --zip-file fileb://build/function.zip\n\naws lambda invoke \\\n  --function-name my-function \\\n  --payload file://test-event.json \\\n  test-response.json\n```\n\n3. Load Testing:\n```bash\nfor i in {1..100}; do\n  aws lambda invoke \\\n    --function-name my-function \\\n    --invocation-type Event \\\n    --payload '{\"test\": '$i'}' \\\n    /dev/null &\ndone\n```\n\nExam Tips:\n‚Ä¢ Command is \"invoke\" not \"execute\", \"run\", or \"call\"\n‚Ä¢ Always specify output file (response.json)\n‚Ä¢ Default invocation type is synchronous (RequestResponse)\n‚Ä¢ --payload is for input data\n‚Ä¢ --log-type Tail includes last 4KB of logs\n\nCommon Mistakes:\n‚ùå aws lambda execute-function (doesn't exist)\n‚ùå aws lambda run-function (doesn't exist)\n‚ùå aws lambda call (doesn't exist)\n‚úì aws lambda invoke (correct!)",
                explanations: {
                    "aws lambda execute-function": "Incorrect. This command doesn't exist.",
                    "aws lambda invoke": "Correct! 'aws lambda invoke' is the correct command to trigger a Lambda function.",
                    "aws lambda run-function": "Incorrect. This command doesn't exist.",
                    "aws lambda call": "Incorrect. This command doesn't exist."
                }
            },
            {
                id: 15,
                domain: "Development",
                type: "Multiple Choice",
                question: "Which S3 storage class is most cost-effective for data that is accessed infrequently but requires millisecond access when needed?",
                options: [
                    { text: "S3 Standard", correct: false },
                    { text: "S3 Intelligent-Tiering", correct: false },
                    { text: "S3 Standard-IA", correct: true },
                    { text: "S3 Glacier", correct: false }
                ],
                materials: "S3 Storage Classes - Cost vs Performance:\n\nThe Requirement:\n‚Ä¢ Infrequently accessed data\n‚Ä¢ BUT need millisecond access when needed\n‚Ä¢ Want to minimize costs\n\nS3 Storage Classes Comparison:\n\n1. S3 Standard:\n   üí∞ Cost: ~$0.023/GB/month\n   ‚ö° Access: Milliseconds\n   üìä Use Case: Frequently accessed data\n   ‚ùå Too expensive for infrequent access\n   ‚Ä¢ 99.99% availability\n   ‚Ä¢ 11 9's durability\n\n2. S3 Standard-IA (Infrequent Access):\n   üí∞ Cost: ~$0.0125/GB/month (46% cheaper!)\n   ‚ö° Access: Milliseconds ‚úì\n   üìä Use Case: Infrequently accessed, instant retrieval\n   ‚úì PERFECT for this scenario\n   ‚Ä¢ 99.9% availability\n   ‚Ä¢ 11 9's durability\n   ‚Ä¢ Minimum 30-day storage\n   ‚Ä¢ Minimum 128 KB per object\n   ‚Ä¢ Retrieval fee: $0.01/GB\n\n3. S3 Intelligent-Tiering:\n   üí∞ Cost: ~$0.023/GB/month + $0.0025 per 1,000 objects\n   ‚ö° Access: Milliseconds\n   üìä Use Case: Unknown/changing access patterns\n   ‚ùå More expensive due to monitoring fees\n   ‚Ä¢ Automatically moves objects between tiers\n   ‚Ä¢ No retrieval fees\n   ‚Ä¢ Good when you don't know access pattern\n\n4. S3 One Zone-IA:\n   üí∞ Cost: ~$0.01/GB/month (cheapest for IA)\n   ‚ö° Access: Milliseconds\n   üìä Use Case: Infrequent, reproducible data\n   ‚ö†Ô∏è Only one AZ (lower availability)\n   ‚Ä¢ 99.5% availability (vs 99.9%)\n   ‚Ä¢ Use for secondary backups\n\n5. S3 Glacier Instant Retrieval:\n   üí∞ Cost: ~$0.004/GB/month\n   ‚ö° Access: Milliseconds\n   üìä Use Case: Archival with instant access\n   ‚Ä¢ Minimum 90-day storage\n   ‚Ä¢ Cheapest with millisecond retrieval\n   ‚Ä¢ Higher retrieval cost: $0.03/GB\n\n6. S3 Glacier Flexible Retrieval:\n   üí∞ Cost: ~$0.0036/GB/month\n   ‚ö° Access: Minutes to hours ‚ùå\n   üìä Use Case: Archive, rare access\n   ‚Ä¢ Expedited: 1-5 minutes ($0.03/GB)\n   ‚Ä¢ Standard: 3-5 hours ($0.01/GB)\n   ‚Ä¢ Bulk: 5-12 hours ($0.0025/GB)\n\n7. S3 Glacier Deep Archive:\n   üí∞ Cost: ~$0.00099/GB/month (cheapest)\n   ‚ö° Access: 12-48 hours ‚ùå\n   üìä Use Case: Long-term archive\n   ‚Ä¢ Minimum 180-day storage\n   ‚Ä¢ For compliance, regulations\n\nDecision Tree:\n\n```\nNeed millisecond access?\n‚îú‚îÄ Yes\n‚îÇ  ‚îú‚îÄ Frequently accessed? ‚Üí S3 Standard\n‚îÇ  ‚îú‚îÄ Infrequently accessed?\n‚îÇ  ‚îÇ  ‚îú‚îÄ Known pattern ‚Üí S3 Standard-IA ‚úì\n‚îÇ  ‚îÇ  ‚îî‚îÄ Unknown pattern ‚Üí S3 Intelligent-Tiering\n‚îÇ  ‚îî‚îÄ Archived data ‚Üí Glacier Instant Retrieval\n‚îÇ\n‚îî‚îÄ No (minutes/hours OK)\n   ‚îú‚îÄ Access in minutes ‚Üí Glacier Flexible\n   ‚îî‚îÄ Access in hours ‚Üí Glacier Deep Archive\n```\n\nFor This Question: S3 Standard-IA\n\nWhy Standard-IA?\n‚úì Infrequent access (low storage cost)\n‚úì Millisecond retrieval (meets requirement)\n‚úì Lower cost than Standard\n‚úì No monitoring fees (vs Intelligent-Tiering)\n‚úì Multi-AZ durability\n\nWhen to Use Each:\n\n‚Ä¢ Standard: Active data, >1/month access\n‚Ä¢ Standard-IA: <1/month access, instant needed\n‚Ä¢ Intelligent-Tiering: Unpredictable patterns\n‚Ä¢ One Zone-IA: Reproducible data, cost priority\n‚Ä¢ Glacier Instant: Archive with instant access\n‚Ä¢ Glacier Flexible: Archive, hours OK\n‚Ä¢ Glacier Deep Archive: Compliance, years retention\n\nCost Breakdown Example:\n1 TB stored for 1 month:\n\n‚Ä¢ Standard: $23.55\n‚Ä¢ Standard-IA: $12.80 + retrieval fees\n‚Ä¢ Intelligent-Tiering: $23.55 + $0.08 monitoring\n‚Ä¢ One Zone-IA: $10.24 + retrieval fees\n‚Ä¢ Glacier Instant: $4.10 + higher retrieval fees\n‚Ä¢ Glacier Flexible: $3.69 + retrieval time\n‚Ä¢ Deep Archive: $1.01 + long retrieval time\n\nImportant Considerations:\n\nStandard-IA Fees:\n‚Ä¢ Storage: Lower than Standard\n‚Ä¢ Retrieval: $0.01 per GB retrieved\n‚Ä¢ Minimum storage duration: 30 days\n‚Ä¢ Minimum object size: 128 KB\n‚Ä¢ Early deletion fee if < 30 days\n\nBreak-Even Analysis:\nStandard-IA makes sense when:\n‚Ä¢ Accessing < 30% of data per month\n‚Ä¢ Objects stored > 30 days\n‚Ä¢ Objects > 128 KB\n\nLifecycle Policies:\nAutomate transitions:\n```\n1. Upload ‚Üí S3 Standard\n2. After 30 days ‚Üí S3 Standard-IA\n3. After 90 days ‚Üí Glacier Flexible\n4. After 365 days ‚Üí Deep Archive\n```\n\nExam Tips:\n‚Ä¢ Infrequent + Milliseconds = Standard-IA\n‚Ä¢ Unknown pattern + Milliseconds = Intelligent-Tiering\n‚Ä¢ Archive + Instant = Glacier Instant Retrieval\n‚Ä¢ Archive + Hours = Glacier Flexible or Deep Archive\n‚Ä¢ Glacier (without \"Instant\") ‚â† Milliseconds",
                explanations: {
                    "S3 Standard": "Incorrect. Standard is for frequently accessed data and costs more.",
                    "S3 Intelligent-Tiering": "Incorrect. This works but costs more due to monitoring fees for infrequent access patterns.",
                    "S3 Standard-IA": "Correct! Standard-IA (Infrequent Access) is optimized for infrequently accessed data with millisecond access times.",
                    "S3 Glacier": "Incorrect. Glacier requires hours for retrieval, not milliseconds."
                }
            },
            {
                id: 16,
                domain: "Development",
                type: "Multiple Choice",
                question: "A developer needs to execute code in response to S3 object uploads. What is the MOST serverless solution?",
                options: [
                    { text: "Configure S3 event notifications to trigger a Lambda function", correct: true },
                    { text: "Use CloudWatch Events to poll S3", correct: false },
                    { text: "Run a cron job on EC2 to check for new objects", correct: false },
                    { text: "Use SQS to poll S3 API", correct: false }
                ],
                materials: "S3 Event Notifications + Lambda Integration:\n\nThe Requirement:\n‚Ä¢ Execute code when files are uploaded to S3\n‚Ä¢ Fully serverless\n‚Ä¢ No infrastructure management\n\nPerfect Solution: S3 Event Notifications ‚Üí Lambda\n\nHow It Works:\n```\n1. User uploads file to S3\n2. S3 generates event notification\n3. Lambda function is automatically triggered\n4. Function processes the file\n5. All automatic, no polling needed!\n```\n\nS3 Event Types:\n\n1. Object Created:\n   ‚Ä¢ s3:ObjectCreated:* (all create events)\n   ‚Ä¢ s3:ObjectCreated:Put (PUT)\n   ‚Ä¢ s3:ObjectCreated:Post (POST)\n   ‚Ä¢ s3:ObjectCreated:Copy (Copy)\n   ‚Ä¢ s3:ObjectCreated:CompleteMultipartUpload\n\n2. Object Removed:\n   ‚Ä¢ s3:ObjectRemoved:*\n   ‚Ä¢ s3:ObjectRemoved:Delete\n   ‚Ä¢ s3:ObjectRemoved:DeleteMarkerCreated\n\n3. Object Restore:\n   ‚Ä¢ s3:ObjectRestore:Post\n   ‚Ä¢ s3:ObjectRestore:Completed\n\n4. Replication:\n   ‚Ä¢ s3:Replication:*\n\n5. Other:\n   ‚Ä¢ s3:ReducedRedundancyLostObject\n   ‚Ä¢ s3:IntelligentTiering\n   ‚Ä¢ s3:LifecycleExpiration:*\n\nSetting Up S3 ‚Üí Lambda:\n\n1. Create Lambda function\n2. Grant S3 permission to invoke Lambda:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Principal\": {\"Service\": \"s3.amazonaws.com\"},\n  \"Action\": \"lambda:InvokeFunction\",\n  \"Resource\": \"arn:aws:lambda:region:account:function:my-function\",\n  \"Condition\": {\n    \"StringEquals\": {\"AWS:SourceAccount\": \"123456789012\"},\n    \"ArnLike\": {\"AWS:SourceArn\": \"arn:aws:s3:::my-bucket\"}\n  }\n}\n```\n\n3. Configure S3 bucket notification:\n```json\n{\n  \"LambdaFunctionConfigurations\": [{\n    \"LambdaFunctionArn\": \"arn:aws:lambda:us-east-1:123456789012:function:my-function\",\n    \"Events\": [\"s3:ObjectCreated:*\"],\n    \"Filter\": {\n      \"Key\": {\n        \"FilterRules\": [\n          {\"Name\": \"prefix\", \"Value\": \"uploads/\"},\n          {\"Name\": \"suffix\", \"Value\": \".jpg\"}\n        ]\n      }\n    }\n  }]\n}\n```\n\nEvent Payload Lambda Receives:\n```json\n{\n  \"Records\": [{\n    \"eventVersion\": \"2.1\",\n    \"eventSource\": \"aws:s3\",\n    \"awsRegion\": \"us-east-1\",\n    \"eventTime\": \"2023-01-01T12:00:00.000Z\",\n    \"eventName\": \"ObjectCreated:Put\",\n    \"s3\": {\n      \"bucket\": {\n        \"name\": \"my-bucket\",\n        \"arn\": \"arn:aws:s3:::my-bucket\"\n      },\n      \"object\": {\n        \"key\": \"uploads/photo.jpg\",\n        \"size\": 1024,\n        \"eTag\": \"abc123\"\n      }\n    }\n  }]\n}\n```\n\nLambda Function Example:\n```python\nimport json\nimport boto3\n\ns3 = boto3.client('s3')\n\ndef lambda_handler(event, context):\n    # Parse S3 event\n    for record in event['Records']:\n        bucket = record['s3']['bucket']['name']\n        key = record['s3']['object']['key']\n        \n        print(f\"Processing {key} from {bucket}\")\n        \n        # Download file\n        response = s3.get_object(Bucket=bucket, Key=key)\n        content = response['Body'].read()\n        \n        # Process file\n        # ... your logic here ...\n        \n        # Upload result\n        s3.put_object(\n            Bucket=bucket,\n            Key=f\"processed/{key}\",\n            Body=processed_content\n        )\n    \n    return {'statusCode': 200}\n```\n\nCommon Use Cases:\n\n1. Image Processing:\n   ‚Ä¢ Upload ‚Üí Resize/optimize ‚Üí Save thumbnail\n\n2. Video Transcoding:\n   ‚Ä¢ Upload video ‚Üí Trigger transcoding ‚Üí Multiple formats\n\n3. Data Processing:\n   ‚Ä¢ Upload CSV ‚Üí Parse ‚Üí Load to database\n\n4. File Validation:\n   ‚Ä¢ Upload ‚Üí Scan for viruses ‚Üí Quarantine if needed\n\n5. Notifications:\n   ‚Ä¢ Upload ‚Üí Send email/Slack notification\n\n6. ETL Pipeline:\n   ‚Ä¢ Upload data file ‚Üí Transform ‚Üí Load to warehouse\n\n7. Backup Automation:\n   ‚Ä¢ Upload ‚Üí Replicate to another region ‚Üí Tag\n\nFiltering Events:\n\nBy Prefix (folder):\n```\nFilter: prefix = \"uploads/\"\nOnly triggers for objects in uploads/ folder\n```\n\nBy Suffix (extension):\n```\nFilter: suffix = \".pdf\"\nOnly triggers for PDF files\n```\n\nCombined:\n```\nPrefix: \"documents/\"\nSuffix: \".pdf\"\nOnly PDFs in documents/ folder\n```\n\nOther Event Destinations:\n\n1. SNS Topic:\n   ‚Ä¢ Fan-out to multiple subscribers\n   ‚Ä¢ Send emails, SMS\n\n2. SQS Queue:\n   ‚Ä¢ Queue for batch processing\n   ‚Ä¢ Decouple processing\n\n3. EventBridge:\n   ‚Ä¢ Advanced routing\n   ‚Ä¢ Multiple targets\n   ‚Ä¢ Transform events\n\nComparison of Approaches:\n\n1. S3 Events + Lambda (BEST - Serverless):\n   ‚úì Fully serverless\n   ‚úì Automatic scaling\n   ‚úì Pay per execution\n   ‚úì No polling overhead\n   ‚úì Near real-time\n   ‚úì No infrastructure\n\n2. CloudWatch Events (Doesn't work):\n   ‚ùå Can't directly poll S3\n   ‚ùå Not designed for this\n\n3. EC2 Cron Job (Not serverless):\n   ‚ùå Must manage EC2\n   ‚ùå Polling overhead\n   ‚ùå Not cost-effective\n   ‚ùå Delay in processing\n   ‚ùå Manual scaling\n\n4. SQS Polling S3 API (Doesn't work):\n   ‚ùå SQS can't poll S3\n   ‚ùå Wrong service\n\nBest Practices:\n\n‚úì Use filters to reduce invocations (costs)\n‚úì Handle errors gracefully (DLQ)\n‚úì Idempotent processing (same file multiple times)\n‚úì Set appropriate Lambda timeout\n‚úì Use S3 Select for large files\n‚úì Consider async processing for large jobs\n‚úì Monitor CloudWatch metrics\n\nIdempotency Consideration:\nS3 can send same event multiple times!\n```python\ndef lambda_handler(event, context):\n    # Track processed files in DynamoDB\n    file_key = event['Records'][0]['s3']['object']['key']\n    etag = event['Records'][0]['s3']['object']['eTag']\n    \n    # Check if already processed\n    if already_processed(file_key, etag):\n        return {'statusCode': 200, 'body': 'Already processed'}\n    \n    # Process...\n    process_file(file_key)\n    \n    # Mark as processed\n    mark_processed(file_key, etag)\n```\n\nCost:\n‚Ä¢ S3 event notifications: FREE\n‚Ä¢ Lambda invocations: $0.20 per 1M requests\n‚Ä¢ Lambda compute: $0.0000166667 per GB-second\n\nExam Tips:\n‚Ä¢ S3 events + Lambda = Serverless, automatic\n‚Ä¢ No polling needed (S3 pushes to Lambda)\n‚Ä¢ CloudWatch Events can't poll S3\n‚Ä¢ EC2 cron is not serverless\n‚Ä¢ Configure both permission AND notification",
                explanations: {
                    "Configure S3 event notifications to trigger a Lambda function": "Correct! This is fully serverless, automatic, and cost-effective. S3 invokes Lambda directly on object events.",
                    "Use CloudWatch Events to poll S3": "Incorrect. CloudWatch Events cannot directly poll S3.",
                    "Run a cron job on EC2 to check for new objects": "Incorrect. This requires managing EC2 instances and isn't serverless.",
                    "Use SQS to poll S3 API": "Incorrect. SQS doesn't poll S3; this adds unnecessary complexity."
                }
            },
            {
                id: 17,
                domain: "Development",
                type: "Multiple Response",
                question: "Which AWS services can be used as event sources for Lambda? (Select TWO)",
                options: [
                    { text: "Amazon S3", correct: true },
                    { text: "Amazon RDS", correct: false },
                    { text: "Amazon DynamoDB Streams", correct: true },
                    { text: "Amazon EBS", correct: false },
                    { text: "Amazon Redshift", correct: false }
                ],
                materials: "Lambda Event Sources - Triggers:\n\nLambda is event-driven. It runs in response to events from various AWS services.\n\nEvent Source Types:\n\n1. Synchronous (Request-Response):\n   ‚Ä¢ API Gateway\n   ‚Ä¢ Application Load Balancer (ALB)\n   ‚Ä¢ CloudFront (Lambda@Edge)\n   ‚Ä¢ Amazon Lex\n   ‚Ä¢ Amazon Alexa\n   ‚Ä¢ Amazon Cognito\n   ‚Ä¢ AWS Step Functions\n\n2. Asynchronous (Event-based):\n   ‚Ä¢ Amazon S3 ‚úì\n   ‚Ä¢ Amazon SNS\n   ‚Ä¢ Amazon SES\n   ‚Ä¢ AWS CloudFormation\n   ‚Ä¢ Amazon CloudWatch Logs\n   ‚Ä¢ Amazon CloudWatch Events/EventBridge\n   ‚Ä¢ AWS CodeCommit\n   ‚Ä¢ AWS Config\n\n3. Poll-based (Stream/Queue):\n   ‚Ä¢ Amazon DynamoDB Streams ‚úì\n   ‚Ä¢ Amazon Kinesis Data Streams\n   ‚Ä¢ Amazon Kinesis Data Firehose\n   ‚Ä¢ Amazon SQS\n   ‚Ä¢ Amazon MQ\n   ‚Ä¢ Apache Kafka (MSK)\n   ‚Ä¢ Self-managed Kafka\n\nDetailed: Amazon S3\n\n‚úì Triggers Lambda on object events\n‚úì Supported events:\n  ‚Ä¢ ObjectCreated (PUT, POST, COPY)\n  ‚Ä¢ ObjectRemoved (DELETE)\n  ‚Ä¢ ObjectRestore\n  ‚Ä¢ Replication events\n‚úì Use cases:\n  ‚Ä¢ Image processing\n  ‚Ä¢ File validation\n  ‚Ä¢ Data transformation\n  ‚Ä¢ ETL pipelines\n\nSetup:\n```\n1. Create Lambda function\n2. Add S3 trigger in Lambda console\n   OR\n   Configure in S3 bucket notifications\n3. Grant permission (automatic if via console)\n4. Upload to S3 ‚Üí Lambda executes!\n```\n\nEvent Example:\n```json\n{\n  \"Records\": [{\n    \"s3\": {\n      \"bucket\": {\"name\": \"my-bucket\"},\n      \"object\": {\"key\": \"photo.jpg\", \"size\": 1024}\n    }\n  }]\n}\n```\n\nDetailed: DynamoDB Streams\n\n‚úì Triggers Lambda on table changes\n‚úì Captures:\n  ‚Ä¢ INSERT: New items\n  ‚Ä¢ MODIFY: Updated items\n  ‚Ä¢ REMOVE: Deleted items\n‚úì Stream views:\n  ‚Ä¢ KEYS_ONLY: Just keys\n  ‚Ä¢ NEW_IMAGE: New state\n  ‚Ä¢ OLD_IMAGE: Previous state\n  ‚Ä¢ NEW_AND_OLD_IMAGES: Both states\n‚úì Use cases:\n  ‚Ä¢ Real-time analytics\n  ‚Ä¢ Audit logging\n  ‚Ä¢ Cross-region replication\n  ‚Ä¢ Trigger workflows\n  ‚Ä¢ Send notifications\n\nSetup:\n```\n1. Enable DynamoDB Streams on table\n2. Create Lambda function\n3. Add DynamoDB Stream trigger\n4. Lambda polls stream automatically\n5. Processes changes in batches\n```\n\nEvent Example:\n```json\n{\n  \"Records\": [{\n    \"eventName\": \"INSERT\",\n    \"dynamodb\": {\n      \"Keys\": {\"id\": {\"S\": \"123\"}},\n      \"NewImage\": {\n        \"id\": {\"S\": \"123\"},\n        \"name\": {\"S\": \"John\"},\n        \"email\": {\"S\": \"john@example.com\"}\n      }\n    }\n  }]\n}\n```\n\nProcessing Pattern:\n```python\ndef lambda_handler(event, context):\n    for record in event['Records']:\n        if record['eventName'] == 'INSERT':\n            new_item = record['dynamodb']['NewImage']\n            # Handle new item\n            \n        elif record['eventName'] == 'MODIFY':\n            old_item = record['dynamodb']['OldImage']\n            new_item = record['dynamodb']['NewImage']\n            # Handle update\n            \n        elif record['eventName'] == 'REMOVE':\n            old_item = record['dynamodb']['OldImage']\n            # Handle deletion\n```\n\nOther Common Event Sources:\n\n1. Amazon SQS:\n   ‚Ä¢ Lambda polls queue\n   ‚Ä¢ Batch processing (1-10 messages)\n   ‚Ä¢ Automatic deletion after success\n   ‚Ä¢ Built-in retry and DLQ support\n\n2. Amazon SNS:\n   ‚Ä¢ Push notifications to Lambda\n   ‚Ä¢ Fan-out pattern\n   ‚Ä¢ One message ‚Üí multiple Lambdas\n\n3. API Gateway:\n   ‚Ä¢ HTTP REST APIs\n   ‚Ä¢ WebSocket APIs\n   ‚Ä¢ Synchronous invocation\n   ‚Ä¢ Returns response to client\n\n4. Amazon Kinesis:\n   ‚Ä¢ Real-time data streaming\n   ‚Ä¢ Lambda processes in batches\n   ‚Ä¢ Ordered processing per shard\n\n5. EventBridge (CloudWatch Events):\n   ‚Ä¢ Scheduled events (cron/rate)\n   ‚Ä¢ AWS service events\n   ‚Ä¢ Custom application events\n\n6. Application Load Balancer:\n   ‚Ä¢ HTTP(S) requests\n   ‚Ä¢ Multi-value headers\n   ‚Ä¢ Returns HTTP response\n\nNOT Event Sources:\n\n‚ùå Amazon RDS:\n   ‚Ä¢ Relational database\n   ‚Ä¢ No direct Lambda trigger\n   ‚Ä¢ Use RDS Proxy events or Aurora serverless\n\n‚ùå Amazon EBS:\n   ‚Ä¢ Block storage\n   ‚Ä¢ No events to trigger Lambda\n\n‚ùå Amazon Redshift:\n   ‚Ä¢ Data warehouse\n   ‚Ä¢ No direct Lambda trigger\n   ‚Ä¢ Can use Redshift Data API from Lambda\n\n‚ùå Amazon EFS:\n   ‚Ä¢ File system\n   ‚Ä¢ No built-in triggers\n   ‚Ä¢ Can mount to Lambda but doesn't trigger it\n\nEvent Source Mapping:\n\nFor poll-based sources (SQS, Kinesis, DynamoDB Streams):\n‚Ä¢ Lambda service polls on your behalf\n‚Ä¢ No cost for polling\n‚Ä¢ Configurable batch size\n‚Ä¢ Configurable batch window\n‚Ä¢ Concurrent batch processing\n‚Ä¢ Error handling options:\n  - Retry with exponential backoff\n  - Split batch on error\n  - Send to DLQ\n  - Maximum retry attempts\n\nPermissions:\n\n1. Push Model (S3, SNS):\n   ‚Ä¢ Event source needs permission to invoke Lambda\n   ‚Ä¢ Resource-based policy on Lambda\n\n2. Pull Model (SQS, DynamoDB, Kinesis):\n   ‚Ä¢ Lambda needs permission to read from source\n   ‚Ä¢ IAM role permissions\n\nExample Architectures:\n\n1. Image Processing:\n```\nS3 Upload ‚Üí Lambda ‚Üí Resize ‚Üí S3\n```\n\n2. Real-time Analytics:\n```\nDynamoDB Update ‚Üí DynamoDB Streams ‚Üí Lambda ‚Üí Kinesis\n```\n\n3. Order Processing:\n```\nAPI Gateway ‚Üí Lambda ‚Üí SQS ‚Üí Lambda ‚Üí DynamoDB\n```\n\n4. Scheduled Jobs:\n```\nEventBridge (cron) ‚Üí Lambda ‚Üí Process\n```\n\nExam Tips:\n‚Ä¢ S3 = Object events (PUT, DELETE) ‚úì\n‚Ä¢ DynamoDB Streams = Table changes (INSERT, MODIFY, REMOVE) ‚úì\n‚Ä¢ RDS = No direct trigger ‚ùå\n‚Ä¢ EBS = No trigger ‚ùå\n‚Ä¢ Redshift = No direct trigger ‚ùå\n‚Ä¢ SQS, Kinesis, DynamoDB Streams use event source mapping (Lambda polls)\n‚Ä¢ S3, SNS push to Lambda (event source invokes)",
                explanations: {
                    "Amazon S3": "Correct! S3 can trigger Lambda on object events (PUT, DELETE, etc.).",
                    "Amazon RDS": "Incorrect. RDS doesn't directly trigger Lambda, though RDS Proxy events can.",
                    "Amazon DynamoDB Streams": "Correct! DynamoDB Streams trigger Lambda functions on table changes.",
                    "Amazon EBS": "Incorrect. EBS doesn't have event-based Lambda triggers.",
                    "Amazon Redshift": "Incorrect. Redshift doesn't directly trigger Lambda functions."
                }
            },
            {
                id: 18,
                domain: "Development",
                type: "Multiple Choice",
                question: "What does eventual consistency mean in DynamoDB?",
                options: [
                    { text: "Data is immediately consistent across all replicas", correct: false },
                    { text: "Reads might not reflect recent write operations", correct: true },
                    { text: "Writes are lost if not confirmed", correct: false },
                    { text: "Data is never consistent", correct: false }
                ],
                materials: "DynamoDB Consistency Models:\n\nThe CAP Theorem Challenge:\nIn distributed systems, you can't have all three:\n‚Ä¢ Consistency (all nodes see same data)\n‚Ä¢ Availability (always get a response)\n‚Ä¢ Partition Tolerance (works despite network issues)\n\nDynamoDB chooses: Availability + Partition Tolerance\nResult: Eventual Consistency (by default)\n\nHow DynamoDB Works:\n\n```\nWrite Request:\nClient ‚Üí Primary Node (writes immediately)\n      ‚Üí Replicates to 2 other nodes\n      ‚Üí Returns success\n\nRead Request:\nClient ‚Üí Any of 3 nodes (could be mid-replication)\n```\n\nEventual Consistency (Default):\n\n‚ö° What happens:\n1. Write goes to primary\n2. Returns success immediately\n3. Replicates to other nodes (takes < 1 second)\n4. Read might hit a node that hasn't been updated yet\n5. Brief window where you might read old data\n\n‚úì Benefits:\n‚Ä¢ Faster reads (50% cheaper RCUs)\n‚Ä¢ Higher availability\n‚Ä¢ Better performance\n‚Ä¢ Lower latency\n\n‚ùå Drawback:\n‚Ä¢ Reads might not reflect recent writes\n‚Ä¢ Usually consistent within 1 second\n‚Ä¢ Not guaranteed immediate consistency\n\nExample:\n```\nTime 0: Write name = \"John\" ‚Üí Returns success\nTime 1: Read name ‚Üí Might return \"Bob\" (old value)\nTime 2: Read name ‚Üí Returns \"John\" (consistent)\n```\n\nStrong Consistency:\n\n‚úì What happens:\n1. Write goes to primary\n2. Replicates to majority of nodes\n3. Returns success\n4. Read waits for latest write to be confirmed\n5. Always returns most recent data\n\n‚úì Benefits:\n‚Ä¢ Guaranteed up-to-date data\n‚Ä¢ Reads reflect all prior writes\n‚Ä¢ No stale data\n\n‚ùå Drawbacks:\n‚Ä¢ Higher latency\n‚Ä¢ More expensive (2x RCUs)\n‚Ä¢ Slightly lower availability\n\nExample:\n```\nTime 0: Write name = \"John\" ‚Üí Returns success\nTime 1: Read name (strong) ‚Üí Returns \"John\" (always latest)\n```\n\nHow to Request Strong Consistency:\n\n```python\nimport boto3\n\ndynamodb = boto3.resource('dynamodb')\ntable = dynamodb.Table('Users')\n\n# Eventual consistency (default)\nresponse = table.get_item(\n    Key={'userId': '123'}\n)\n\n# Strong consistency (explicit)\nresponse = table.get_item(\n    Key={'userId': '123'},\n    ConsistentRead=True  # ‚Üê This requests strong consistency\n)\n```\n\nRCU Cost Comparison:\n\n```\nReading 8 KB item:\n‚Ä¢ Eventual consistency: 1 RCU\n‚Ä¢ Strong consistency: 2 RCUs\n\nReading 100 items (8 KB each):\n‚Ä¢ Eventual consistency: 100 RCUs\n‚Ä¢ Strong consistency: 200 RCUs\n\nCost difference: 2x for strong consistency!\n```\n\nOperations and Consistency:\n\n1. Read Operations:\n   ‚Ä¢ GetItem: Eventual (default) or Strong\n   ‚Ä¢ Query: Eventual (default) or Strong\n   ‚Ä¢ Scan: Eventual (default) or Strong\n   ‚Ä¢ BatchGetItem: Eventual (default) or Strong\n\n2. Write Operations:\n   ‚Ä¢ PutItem: Always strongly consistent\n   ‚Ä¢ UpdateItem: Always strongly consistent\n   ‚Ä¢ DeleteItem: Always strongly consistent\n   ‚Ä¢ All writes are immediately consistent\n\n3. Secondary Indexes:\n   ‚Ä¢ LSI (Local): Can be strongly consistent\n   ‚Ä¢ GSI (Global): ALWAYS eventually consistent\n   ‚Ä¢ GSIs can't use ConsistentRead=True\n\nReal-World Scenarios:\n\nUse Eventual Consistency When:\n‚úì Reading analytics/dashboards\n‚úì Viewing product listings\n‚úì Social media feeds\n‚úì Comments/reviews\n‚úì Historical data\n‚úì Search results\n‚úì Cost-sensitive applications\n‚úì High-throughput reads\n\nUse Strong Consistency When:\n‚úì Financial transactions\n‚úì Inventory management (stock levels)\n‚úì Booking systems (seats, rooms)\n‚úì User authentication\n‚úì Critical business data\n‚úì Read-after-write scenarios\n‚úì Compliance requirements\n\nCommon Pattern - Read After Write:\n\n```python\n# Write user profile\ntable.put_item(Item={'userId': '123', 'name': 'John'})\n\n# Immediately read back (use strong consistency!)\nresponse = table.get_item(\n    Key={'userId': '123'},\n    ConsistentRead=True  # ‚Üê Important for read-after-write\n)\n```\n\nWithout ConsistentRead=True:\n‚Ä¢ Might read old data (or no data)\n‚Ä¢ Write succeeded but read returns stale\n\nGlobal Tables and Consistency:\n\n‚Ä¢ Multi-region replication\n‚Ä¢ ALWAYS eventually consistent across regions\n‚Ä¢ Can't be strongly consistent globally\n‚Ä¢ Typical replication time: < 1 second\n‚Ä¢ Use for disaster recovery and low latency\n\nBest Practices:\n\n‚úì Default to eventual consistency (cost/performance)\n‚úì Use strong consistency only when needed\n‚úì Don't mix consistency models unnecessarily\n‚úì Document when strong consistency is required\n‚úì Consider application-level caching\n‚úì Design for eventual consistency when possible\n\nExam Tips:\n‚Ä¢ Eventual consistency = Might read stale data ‚úì\n‚Ä¢ Strong consistency = Always latest data\n‚Ä¢ Eventual is DEFAULT\n‚Ä¢ Eventual is 50% cheaper (RCUs)\n‚Ä¢ GSIs are ALWAYS eventually consistent\n‚Ä¢ LSIs can be strongly consistent\n‚Ä¢ ConsistentRead=True for strong consistency\n‚Ä¢ Writes are always immediately consistent\n\nCommon Mistake:\nThinking eventual = Data is never consistent\nReality: Data becomes consistent quickly (< 1 second), just not guaranteed immediate",
                explanations: {
                    "Data is immediately consistent across all replicas": "Incorrect. This describes strong consistency, not eventual consistency.",
                    "Reads might not reflect recent write operations": "Correct! With eventual consistency, reads may return stale data briefly until all replicas sync.",
                    "Writes are lost if not confirmed": "Incorrect. Writes are always durable once acknowledged.",
                    "Data is never consistent": "Incorrect. Data becomes consistent eventually, typically within one second."
                }
            },
            {
                id: 19,
                domain: "Development",
                type: "Multiple Choice",
                question: "A Lambda function needs to connect to an RDS database in a private subnet. What must be configured?",
                options: [
                    { text: "Deploy Lambda in the same VPC and subnet as RDS", correct: true },
                    { text: "Enable public access on RDS", correct: false },
                    { text: "Use AWS Direct Connect", correct: false },
                    { text: "Create a VPN connection", correct: false }
                ],
                materials: "Lambda VPC Integration - Accessing Private Resources:\n\nThe Problem:\n‚Ä¢ RDS database in private subnet (no internet access)\n‚Ä¢ Lambda function (by default) runs outside your VPC\n‚Ä¢ Can't connect to private RDS!\n\nThe Solution: Lambda VPC Configuration\n\nHow Lambda Networking Works:\n\nDefault (No VPC):\n```\nLambda Function (AWS managed network)\n  ‚Üì\n  ‚úì Can access: Internet, AWS services\n  ‚ùå Cannot access: Resources in your private VPC\n```\n\nWith VPC Configuration:\n```\nLambda Function (your VPC)\n  ‚Üì\n  ‚úì Can access: Resources in VPC (RDS, ElastiCache)\n  ‚ùå Cannot access: Internet (without NAT)\n  ‚ùå Cannot access: AWS services (without VPC endpoints)\n```\n\nConfiguring Lambda for VPC Access:\n\n1. Requirements:\n   ‚úì VPC ID\n   ‚úì Subnet IDs (choose at least 2 for HA)\n   ‚úì Security Group IDs\n   ‚úì IAM permissions for ENI management\n\n2. What AWS Does:\n   ‚Ä¢ Creates Elastic Network Interfaces (ENIs)\n   ‚Ä¢ Attaches ENIs to your subnets\n   ‚Ä¢ Lambda uses ENIs to access VPC resources\n   ‚Ä¢ ENIs get private IP addresses from subnets\n\n3. IAM Permissions Needed:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": [\n    \"ec2:CreateNetworkInterface\",\n    \"ec2:DescribeNetworkInterfaces\",\n    \"ec2:DeleteNetworkInterface\",\n    \"ec2:AssignPrivateIpAddresses\",\n    \"ec2:UnassignPrivateIpAddresses\"\n  ],\n  \"Resource\": \"*\"\n}\n```\n\nArchitecture:\n\n```\nVPC (10.0.0.0/16)\n‚îú‚îÄ Public Subnet (10.0.1.0/24)\n‚îÇ  ‚îî‚îÄ NAT Gateway (for internet access)\n‚îÇ\n‚îî‚îÄ Private Subnet (10.0.2.0/24)\n   ‚îú‚îÄ RDS Database (10.0.2.10)\n   ‚îî‚îÄ Lambda ENI (10.0.2.50) ‚Üê Lambda uses this\n```\n\nConnection Flow:\n\n1. Lambda Invoked:\n```\nUser/Event ‚Üí Lambda Service\n              ‚Üì\n        Uses existing ENI or creates new\n              ‚Üì\n        ENI in your private subnet\n              ‚Üì\n        Connects to RDS\n```\n\n2. Security Groups:\n```\nLambda Security Group (outbound):\n‚Ä¢ Allow all outbound traffic\n\nRDS Security Group (inbound):\n‚Ä¢ Allow port 3306 from Lambda SG\n‚Ä¢ Source: Lambda's security group\n```\n\nConfiguration Example:\n\n```python\n# AWS CLI\naws lambda update-function-configuration \\\n  --function-name my-function \\\n  --vpc-config SubnetIds=subnet-abc123,subnet-def456,SecurityGroupIds=sg-123456\n\n# CloudFormation\nMyFunction:\n  Type: AWS::Lambda::Function\n  Properties:\n    VpcConfig:\n      SecurityGroupIds:\n        - sg-123456\n      SubnetIds:\n        - subnet-abc123\n        - subnet-def456\n```\n\nLambda Function Code:\n\n```python\nimport pymysql\nimport os\n\ndef lambda_handler(event, context):\n    # RDS endpoint (private)\n    connection = pymysql.connect(\n        host='mydb.abc123.us-east-1.rds.amazonaws.com',\n        user='admin',\n        password=os.environ['DB_PASSWORD'],\n        database='myapp'\n    )\n    \n    with connection.cursor() as cursor:\n        cursor.execute(\"SELECT * FROM users\")\n        result = cursor.fetchall()\n    \n    connection.close()\n    return {'users': result}\n```\n\nSubnet Selection:\n\n‚úì Use Private Subnets:\n‚Ä¢ Lambda doesn't need public IP\n‚Ä¢ More secure\n‚Ä¢ RDS typically in private subnets\n\n‚úì Multi-AZ:\n‚Ä¢ Configure at least 2 subnets in different AZs\n‚Ä¢ High availability\n‚Ä¢ Failover capability\n\n‚ùå Don't:\n‚Ä¢ Put Lambda in public subnet (unnecessary)\n‚Ä¢ Use single subnet (no HA)\n\nInternet Access from VPC Lambda:\n\nThe Problem:\n```\nLambda in VPC ‚Üí No internet access by default\n‚Ä¢ Can't call external APIs\n‚Ä¢ Can't access AWS services\n```\n\nSolution 1: NAT Gateway (for internet)\n```\nPrivate Subnet ‚Üí NAT Gateway ‚Üí Internet Gateway ‚Üí Internet\n\nLambda ‚Üí NAT (in public subnet) ‚Üí IGW ‚Üí External API\n```\n\nCost: ~$32/month + data transfer\n\nSolution 2: VPC Endpoints (for AWS services)\n```\nLambda ‚Üí VPC Endpoint ‚Üí AWS Service (S3, DynamoDB, etc.)\n\nNo internet needed!\nNo NAT Gateway costs!\n```\n\nCommon VPC Endpoints:\n‚Ä¢ S3 (Gateway endpoint - free!)\n‚Ä¢ DynamoDB (Gateway endpoint - free!)\n‚Ä¢ Secrets Manager (Interface endpoint - ~$7/month)\n‚Ä¢ Systems Manager (Interface endpoint)\n‚Ä¢ SQS, SNS, etc.\n\nBest Practices:\n\n‚úì Use private subnets for Lambda\n‚úì Configure multiple subnets (2+ AZs)\n‚úì Use security groups for access control\n‚úì Use VPC endpoints for AWS services (avoid NAT costs)\n‚úì Only enable VPC if needed (adds cold start time)\n‚úì Reuse ENIs (kept warm for ~15 minutes)\n‚úì Monitor ENI usage with CloudWatch\n\nPerformance Considerations:\n\nCold Start:\n‚Ä¢ First invocation: Creates ENI (~10-30 seconds)\n‚Ä¢ Subsequent: Uses existing ENI (fast)\n‚Ä¢ ENIs are reused across invocations\n‚Ä¢ Keep Lambda \"warm\" to avoid ENI creation\n\nImprovement (2019):\n‚Ä¢ AWS improved VPC Lambda performance\n‚Ä¢ Hyperplane ENIs (shared, faster)\n‚Ä¢ Cold start reduced significantly\n\nAlternatives (If RDS Must Be Accessible):\n\n‚ùå Don't: Enable public access on RDS\n‚Ä¢ Security risk\n‚Ä¢ Exposed to internet\n‚Ä¢ Not recommended\n\n‚ùå Don't: Use AWS Direct Connect\n‚Ä¢ For on-premises connectivity\n‚Ä¢ Overkill for Lambda‚ÜíRDS\n\n‚ùå Don't: Create VPN connection\n‚Ä¢ For external network connectivity\n‚Ä¢ Not for Lambda in same account\n\nTroubleshooting:\n\n1. Can't connect to RDS:\n   ‚Ä¢ Check security group rules\n   ‚Ä¢ Verify Lambda is in same VPC\n   ‚Ä¢ Check subnet routing\n   ‚Ä¢ Verify RDS endpoint\n\n2. Timeout errors:\n   ‚Ä¢ Increase Lambda timeout\n   ‚Ä¢ Check network ACLs\n   ‚Ä¢ Verify subnet has route to RDS\n\n3. Can't access internet:\n   ‚Ä¢ Add NAT Gateway\n   ‚Ä¢ Update route table\n   ‚Ä¢ Or use VPC endpoints for AWS services\n\nExam Tips:\n‚Ä¢ Private RDS + Lambda = VPC configuration required ‚úì\n‚Ä¢ Lambda must be deployed in same VPC as RDS\n‚Ä¢ Use private subnets (RDS typically private)\n‚Ä¢ Configure security groups for access\n‚Ä¢ Don't enable public access on RDS (security risk)\n‚Ä¢ Direct Connect and VPN are for external connectivity\n‚Ä¢ VPC Lambda needs NAT or VPC endpoints for internet/AWS services",
                explanations: {
                    "Deploy Lambda in the same VPC and subnet as RDS": "Correct! Lambda must be configured with VPC access, proper subnets, and security groups to reach RDS.",
                    "Enable public access on RDS": "Incorrect. This is a security risk and shouldn't be done for private databases.",
                    "Use AWS Direct Connect": "Incorrect. Direct Connect is for on-premises connectivity, not Lambda to RDS.",
                    "Create a VPN connection": "Incorrect. VPN is for external connectivity, not Lambda to RDS in the same AWS account."
                }
            },
            {
                id: 20,
                domain: "Development",
                type: "Multiple Choice",
                question: "Which API Gateway caching behavior reduces the number of calls to backend services?",
                options: [
                    { text: "Caching request headers", correct: false },
                    { text: "Caching responses for a configured TTL", correct: true },
                    { text: "Caching authentication tokens", correct: false },
                    { text: "Caching API Gateway logs", correct: false }
                ],
                materials: "API Gateway Caching - Response Optimization:\n\nThe Problem:\n‚Ä¢ API receives same request multiple times\n‚Ä¢ Backend service (Lambda/EC2) called each time\n‚Ä¢ Increases latency\n‚Ä¢ Increases cost\n‚Ä¢ Unnecessary load on backend\n\nThe Solution: API Gateway Caching\n\nWhat Is API Gateway Caching?\n\n‚Ä¢ Stores API responses for a configurable TTL\n‚Ä¢ Subsequent identical requests served from cache\n‚Ä¢ No backend invocation needed\n‚Ä¢ Dramatically reduces latency and costs\n\nHow It Works:\n\n```\nRequest 1 (Cache Miss):\nClient ‚Üí API Gateway (check cache) ‚Üí MISS\n       ‚Üí Backend (Lambda/EC2) ‚Üí Response\n       ‚Üí Cache response ‚Üí Return to client\n\nRequest 2 (Cache Hit):\nClient ‚Üí API Gateway (check cache) ‚Üí HIT!\n       ‚Üí Return cached response (no backend call)\n```\n\nBenefits:\n\n‚úì Reduced Latency:\n  ‚Ä¢ Cache hit: < 10ms\n  ‚Ä¢ Backend call: 100-1000ms\n  ‚Ä¢ 10-100x faster!\n\n‚úì Reduced Cost:\n  ‚Ä¢ No Lambda invocations for cached requests\n  ‚Ä¢ Lower Lambda compute costs\n  ‚Ä¢ Fewer database queries\n\n‚úì Reduced Load:\n  ‚Ä¢ Backend handles fewer requests\n  ‚Ä¢ Database under less stress\n  ‚Ä¢ Better scalability\n\n‚úì Improved UX:\n  ‚Ä¢ Faster response times\n  ‚Ä¢ Better user experience\n  ‚Ä¢ Higher throughput\n\nConfiguration:\n\n1. Enable Caching:\n```\nAPI Gateway Console:\n  ‚Üí Stages\n  ‚Üí Select stage (e.g., prod)\n  ‚Üí Settings\n  ‚Üí Enable API cache\n  ‚Üí Select cache capacity (0.5GB - 237GB)\n```\n\n2. Cache Capacity Options:\n   ‚Ä¢ 0.5 GB: $0.020/hour (~$14/month)\n   ‚Ä¢ 1.6 GB: $0.038/hour (~$27/month)\n   ‚Ä¢ 6.1 GB: $0.200/hour (~$144/month)\n   ‚Ä¢ 13.5 GB: $0.250/hour (~$180/month)\n   ‚Ä¢ 28.4 GB: $0.500/hour (~$360/month)\n   ‚Ä¢ 58.2 GB: $1.000/hour (~$720/month)\n   ‚Ä¢ 118 GB: $1.900/hour (~$1,368/month)\n   ‚Ä¢ 237 GB: $3.800/hour (~$2,736/month)\n\n3. TTL (Time-To-Live):\n   ‚Ä¢ Default: 300 seconds (5 minutes)\n   ‚Ä¢ Range: 0 - 3600 seconds (1 hour)\n   ‚Ä¢ Configurable per stage\n   ‚Ä¢ Can override per method\n\nCache Keys:\n\nWhat makes requests unique?\n\nDefault Cache Key:\n‚Ä¢ HTTP method (GET, POST, etc.)\n‚Ä¢ Resource path (/users, /products)\n\nCustom Cache Keys (add these):\n‚Ä¢ Query string parameters\n‚Ä¢ Request headers\n‚Ä¢ Path parameters\n\nExample:\n```\nGET /products?category=electronics&page=1\nGET /products?category=electronics&page=2\n\nWithout query params in cache key: Same cache entry ‚ùå\nWith query params in cache key: Different cache entries ‚úì\n```\n\nConfiguration:\n```\nMethod Request:\n  ‚Üí URL Query String Parameters\n  ‚Üí Add: category, page\n  ‚Üí Check \"Caching\"\n```\n\nCache Control:\n\n1. Client-Side Cache Invalidation:\n```\nRequest with header:\nCache-Control: max-age=0\n\nBypass cache and get fresh data\n```\n\n2. Server-Side Cache Invalidation:\n```bash\n# Invalidate entire cache\naws apigateway flush-stage-cache \\\n  --rest-api-id abc123 \\\n  --stage-name prod\n```\n\n3. Require Authorization:\n   ‚Ä¢ Client must have execute-api:InvalidateCache permission\n   ‚Ä¢ Prevents unauthorized cache bypass\n\nExample Use Cases:\n\n1. Product Catalog:\n```\nGET /products\n‚Ä¢ Response changes infrequently\n‚Ä¢ Cache for 1 hour\n‚Ä¢ Huge cost savings!\n```\n\n2. User Profile:\n```\nGET /users/{userId}\n‚Ä¢ Profile updates are rare\n‚Ä¢ Cache for 5 minutes\n‚Ä¢ Reduce database load\n```\n\n3. Search Results:\n```\nGET /search?q=laptop\n‚Ä¢ Popular searches cached\n‚Ä¢ Cache for 10 minutes\n‚Ä¢ Faster for all users\n```\n\nWhen NOT to Cache:\n\n‚ùå POST/PUT/DELETE requests:\n   ‚Ä¢ Modify data\n   ‚Ä¢ Should not be cached\n   ‚Ä¢ Always hit backend\n\n‚ùå Personalized content:\n   ‚Ä¢ Different per user\n   ‚Ä¢ Use authorization token in cache key\n   ‚Ä¢ Or don't cache\n\n‚ùå Real-time data:\n   ‚Ä¢ Stock prices\n   ‚Ä¢ Live scores\n   ‚Ä¢ Need immediate updates\n\n‚ùå Sensitive data:\n   ‚Ä¢ Financial transactions\n   ‚Ä¢ Personal information\n   ‚Ä¢ Risk of data leakage\n\nCache Encryption:\n\n‚Ä¢ Always encrypted at rest\n‚Ä¢ Uses AWS-managed keys\n‚Ä¢ Automatic\n‚Ä¢ No configuration needed\n\nCacheperformance Metrics:\n\nCloudWatch Metrics:\n‚Ä¢ CacheHitCount: Requests served from cache\n‚Ä¢ CacheMissCount: Requests went to backend\n‚Ä¢ CacheHitRate: Hit / (Hit + Miss)\n\nGood Cache Hit Rate:\n‚Ä¢ > 80%: Excellent\n‚Ä¢ 50-80%: Good\n‚Ä¢ < 50%: Review caching strategy\n\nMonitoring:\n```bash\naws cloudwatch get-metric-statistics \\\n  --namespace AWS/ApiGateway \\\n  --metric-name CacheHitCount \\\n  --dimensions Name=ApiName,Value=MyAPI \\\n  --start-time 2023-01-01T00:00:00Z \\\n  --end-time 2023-01-02T00:00:00Z \\\n  --period 3600 \\\n  --statistics Sum\n```\n\nAdvanced Configuration:\n\n1. Per-Method Settings:\n```\n‚Ä¢ GET /products: Cache for 1 hour\n‚Ä¢ GET /inventory: Cache for 1 minute (more dynamic)\n‚Ä¢ POST /orders: No caching\n```\n\n2. Cache Key Parameters:\n```\n‚Ä¢ Include: userId (personalized cache)\n‚Ä¢ Include: Accept-Language (localization)\n‚Ä¢ Include: API key (multi-tenant)\n```\n\n3. Cache Invalidation Strategy:\n```\n‚Ä¢ Manual: After data updates\n‚Ä¢ Automatic: Short TTL\n‚Ä¢ Hybrid: Long TTL + invalidation on updates\n```\n\nCost-Benefit Analysis:\n\nWithout Caching:\n```\n1 million requests/month\n√ó $0.20/million requests (Lambda)\n√ó Average 200ms execution\n= $0.20 (requests) + $X (compute)\n```\n\nWith Caching (80% hit rate):\n```\n200,000 backend requests (20% miss)\n√ó $0.20/million\n= $0.04 (Lambda)\n+ $14/month (0.5GB cache)\n= $14.04 total\n\nSavings: Significant on compute + latency!\n```\n\nBest Practices:\n\n‚úì Start with small cache size (0.5GB)\n‚úì Monitor cache hit rate\n‚úì Use appropriate TTL for data freshness\n‚úì Include necessary parameters in cache key\n‚úì Require authorization for cache invalidation\n‚úì Cache GET requests, not POST/PUT/DELETE\n‚úì Test cache behavior before production\n‚úì Monitor CloudWatch metrics\n\nExam Tips:\n‚Ä¢ Caching stores RESPONSES (not headers, not tokens)\n‚Ä¢ Reduces backend calls (Lambda invocations)\n‚Ä¢ TTL controls how long responses are cached\n‚Ä¢ Cache key determines uniqueness\n‚Ä¢ Not for authentication/authorization caching (that's separate)\n‚Ä¢ Not for logging caching\n‚Ä¢ Response caching = The answer!",
                explanations: {
                    "Caching request headers": "Incorrect. Headers aren't cached; responses are.",
                    "Caching responses for a configured TTL": "Correct! API Gateway caches endpoint responses, serving them directly without calling the backend during the TTL period.",
                    "Caching authentication tokens": "Incorrect. While authorizers can be cached, this isn't the main caching behavior for reducing backend calls.",
                    "Caching API Gateway logs": "Incorrect. Log caching doesn't reduce backend calls."
                }
            },
            {
                id: 21,
                domain: "Development",
                type: "Multiple Choice",
                question: "What is the maximum size of an item in DynamoDB?",
                options: [
                    { text: "100 KB", correct: false },
                    { text: "400 KB", correct: true },
                    { text: "1 MB", correct: false },
                    { text: "10 MB", correct: false }
                ],
                materials: "DynamoDB Item Size Limit:\n\nMaximum Item Size: 400 KB\n\nWhat Counts Toward the Limit?\n\n‚úì All attribute names\n‚úì All attribute values\n‚úì Everything in the item!\n\nExample:\n```json\n{\n  \"userId\": \"user123\",          // Counts toward 400 KB\n  \"name\": \"John Doe\",           // Counts toward 400 KB\n  \"email\": \"john@example.com\",  // Counts toward 400 KB\n  \"profilePicture\": \"base64...\", // If too large, exceeds limit!\n}\n```\n\nSize Calculation:\n\n‚Ä¢ Attribute names: UTF-8 encoded bytes\n‚Ä¢ String values: UTF-8 encoded bytes\n‚Ä¢ Number values: Variable (up to 38 digits)\n‚Ä¢ Binary values: Raw byte length\n‚Ä¢ Boolean: 1 byte\n‚Ä¢ Null: 1 byte\n‚Ä¢ Lists and Maps: Sum of all nested elements\n\nExample Calculation:\n```\nAttribute \"userId\": \"user123\"\n‚Ä¢ Name \"userId\": 6 bytes\n‚Ä¢ Value \"user123\": 7 bytes\n‚Ä¢ Total: 13 bytes\n\nFor entire item: Sum all attributes\n```\n\nWhy the 400 KB Limit?\n\n‚Ä¢ DynamoDB designed for low-latency\n‚Ä¢ Smaller items = faster reads/writes\n‚Ä¢ Partition key distribution\n‚Ä¢ Network efficiency\n‚Ä¢ Cost optimization\n\nWhat Happens if You Exceed?\n\n```\nPutItem with 500 KB item:\n‚Üí ValidationException\n‚Üí \"Item size has exceeded the maximum allowed size\"\n‚Üí Request fails\n```\n\nStrategies for Large Data:\n\n1. Store Large Data in S3:\n```python\n# Upload large file to S3\ns3.put_object(\n    Bucket='my-bucket',\n    Key=f'profiles/{user_id}.jpg',\n    Body=profile_picture\n)\n\n# Store S3 reference in DynamoDB\ntable.put_item(Item={\n    'userId': user_id,\n    'name': 'John Doe',\n    'profilePictureUrl': f's3://my-bucket/profiles/{user_id}.jpg'\n})\n\n# Item size: Only metadata, not the actual image!\n```\n\n2. Compress Data:\n```python\nimport gzip\n\n# Compress before storing\ncompressed = gzip.compress(large_data.encode())\n\ntable.put_item(Item={\n    'id': '123',\n    'data': compressed  # Much smaller!\n})\n```\n\n3. Split into Multiple Items:\n```python\n# Instead of one large item:\n{\n  'orderId': '123',\n  'items': [1000 items]  # Too large!\n}\n\n# Split into chunks:\n{\n  'orderId': '123',\n  'chunk': 1,\n  'items': [items 1-100]\n}\n{\n  'orderId': '123',\n  'chunk': 2,\n  'items': [items 101-200]\n}\n```\n\n4. Use Item Collections (with LSI):\n```\nPartition Key: orderId\nSort Key: itemId\n\nOne order ‚Üí Multiple items\nQuery returns all items for order\n```\n\n5. Normalize Data:\n```\n# Instead of embedding everything:\nOrder: {orderId, customerId, [all items], [customer details]}\n\n# Normalize:\nOrder: {orderId, customerId, itemCount}\nOrderItem: {orderId, itemId, details}\nCustomer: {customerId, details}\n\n# Fetch as needed\n```\n\nCommon Scenarios:\n\n1. User Profile with Image:\n   ‚ùå Store image in DynamoDB (likely too large)\n   ‚úì Store image in S3, reference in DynamoDB\n\n2. Product with Reviews:\n   ‚ùå Embed all reviews in product item\n   ‚úì Separate items for reviews, query by productId\n\n3. Document Storage:\n   ‚ùå Store entire PDF in DynamoDB\n   ‚úì Store in S3, metadata in DynamoDB\n\n4. Time Series Data:\n   ‚ùå One item with all data points\n   ‚úì One item per time period\n\n5. Shopping Cart:\n   ‚ùå One item with unlimited items\n   ‚úì Split into multiple items if cart grows large\n\nMonitoring Item Sizes:\n\n```python\nimport sys\nimport json\n\ndef calculate_item_size(item):\n    \"\"\"Estimate DynamoDB item size\"\"\"\n    json_str = json.dumps(item)\n    return sys.getsizeof(json_str)\n\nitem_size = calculate_item_size(my_item)\nif item_size > 400_000:  # 400 KB\n    print(\"Item too large!\")\n```\n\nBest Practices:\n\n‚úì Design for small items (< 4 KB ideal)\n‚úì Store large binary data in S3\n‚úì Use references (URLs, keys) in DynamoDB\n‚úì Monitor item sizes in development\n‚úì Plan for data growth\n‚úì Compress data when possible\n‚úì Split large collections\n‚úì Normalize related data\n\nComparison with Other Services:\n\n‚Ä¢ DynamoDB: 400 KB per item\n‚Ä¢ S3: 5 TB per object\n‚Ä¢ DocumentDB: 16 MB per document\n‚Ä¢ RDS MySQL: Row size varies, typically 65 KB default\n‚Ä¢ ElastiCache: Varies by instance type\n\nAttribute Size Limits:\n\n‚Ä¢ Partition key: Max 2048 bytes\n‚Ä¢ Sort key: Max 1024 bytes\n‚Ä¢ Attribute name: Max 64 KB (but counts toward item)\n‚Ä¢ String/Binary: Max 400 KB (entire item)\n‚Ä¢ Number: Max 38 significant digits\n‚Ä¢ List: Max 400 KB (entire item)\n‚Ä¢ Map: Max 400 KB (entire item)\n\nExam Tips:\n‚Ä¢ Remember: 400 KB (not 100 KB, not 1 MB)\n‚Ä¢ Includes attribute names AND values\n‚Ä¢ For large data: Use S3 + store reference\n‚Ä¢ Common pattern: DynamoDB for metadata, S3 for content\n‚Ä¢ Item size violations cause ValidationException\n‚Ä¢ Design tip: Keep items small for performance",
                explanations: {
                    "100 KB": "Incorrect. The limit is higher than this.",
                    "400 KB": "Correct! DynamoDB items cannot exceed 400 KB, including attribute names and values.",
                    "1 MB": "Incorrect. This exceeds DynamoDB's item size limit.",
                    "10 MB": "Incorrect. This far exceeds the limit."
                }
            },
            // DOMAIN 2: Security (26% - 17 questions)
            {
                id: 22,
                domain: "Security",
                type: "Multiple Choice",
                question: "A developer needs to grant an EC2 instance access to an S3 bucket. What is the MOST secure method?",
                options: [
                    { text: "Store AWS credentials in the application code", correct: false },
                    { text: "Attach an IAM role to the EC2 instance", correct: true },
                    { text: "Use environment variables to store access keys", correct: false },
                    { text: "Create an IAM user and store credentials in a file", correct: false }
                ],
                materials: "EC2 + S3 Access - Security Best Practices:\n\nThe Requirement:\nEC2 instance needs to access S3 bucket securely\n\nComparison of Approaches:\n\n‚ùå BAD: Hardcode Credentials in Code\n```python\n# DON'T DO THIS!\nimport boto3\n\ns3 = boto3.client('s3',\n    aws_access_key_id='AKIAIOSFODNN7EXAMPLE',\n    aws_secret_access_key='wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY'\n)\n```\nProblems:\n‚Ä¢ Credentials in source code (GitHub, etc.)\n‚Ä¢ Anyone with code access has credentials\n‚Ä¢ Hard to rotate\n‚Ä¢ Security nightmare!\n\n‚ùå BAD: Environment Variables\n```bash\nexport AWS_ACCESS_KEY_ID=AKI...\nexport AWS_SECRET_ACCESS_KEY=wJal...\n```\nProblems:\n‚Ä¢ Still long-term credentials\n‚Ä¢ Must manage and rotate manually\n‚Ä¢ Can leak in process listings\n‚Ä¢ Better than hardcoding, but not best\n\n‚ùå BAD: IAM User + Credentials File\n```\n~/.aws/credentials:\n[default]\naws_access_key_id=AKI...\naws_secret_access_key=wJal...\n```\nProblems:\n‚Ä¢ Long-term credentials on disk\n‚Ä¢ File permissions issues\n‚Ä¢ Manual key rotation\n‚Ä¢ What if instance is compromised?\n\n‚úì BEST: IAM Role\n\nHow IAM Roles Work for EC2:\n\n1. Create IAM Role:\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Action\": [\n      \"s3:GetObject\",\n      \"s3:PutObject\",\n      \"s3:ListBucket\"\n    ],\n    \"Resource\": [\n      \"arn:aws:s3:::my-bucket\",\n      \"arn:aws:s3:::my-bucket/*\"\n    ]\n  }]\n}\n```\n\n2. Attach Role to EC2 Instance:\n‚Ä¢ At launch time, or\n‚Ä¢ To existing instance\n\n3. Application Code (No Credentials!):\n```python\nimport boto3\n\n# No credentials needed!\n# SDK automatically uses instance role\ns3 = boto3.client('s3')\n\nresponse = s3.get_object(\n    Bucket='my-bucket',\n    Key='file.txt'\n)\n```\n\nHow It Works Behind the Scenes:\n\n```\n1. EC2 instance has attached IAM role\n2. Application requests AWS credentials\n3. EC2 metadata service provides temporary credentials\n4. Credentials auto-rotate every hour\n5. Application uses credentials to access S3\n```\n\nEC2 Instance Metadata Service:\n\n```bash\n# From within EC2 instance:\ncurl http://169.254.169.254/latest/meta-data/iam/security-credentials/MyRole\n\n# Returns:\n{\n  \"AccessKeyId\": \"ASIA...\",\n  \"SecretAccessKey\": \"wJal...\",\n  \"Token\": \"FQoGZXIvY...\",\n  \"Expiration\": \"2023-01-01T12:00:00Z\"\n}\n```\n\n‚Ä¢ Temporary credentials (expire in 1 hour)\n‚Ä¢ Automatically refreshed\n‚Ä¢ No manual management needed\n\nBenefits of IAM Roles:\n\n‚úì No Long-Term Credentials:\n  ‚Ä¢ Temporary credentials only\n  ‚Ä¢ Auto-rotate every hour\n  ‚Ä¢ Can't be stolen and reused long-term\n\n‚úì No Credential Management:\n  ‚Ä¢ No keys to store\n  ‚Ä¢ No keys to rotate\n  ‚Ä¢ No keys to accidentally commit to Git\n\n‚úì Least Privilege:\n  ‚Ä¢ Grant only needed permissions\n  ‚Ä¢ Easy to update policy\n  ‚Ä¢ Centralized management\n\n‚úì Audit Trail:\n  ‚Ä¢ CloudTrail logs all API calls\n  ‚Ä¢ Know which role was used\n  ‚Ä¢ Track access patterns\n\n‚úì Easy Rotation:\n  ‚Ä¢ Update role policy\n  ‚Ä¢ Takes effect immediately\n  ‚Ä¢ No code changes needed\n\nReal-World Architecture:\n\n```\n[EC2 Instance] ‚Üêattached‚Üí [IAM Role]\n      ‚Üì                           ‚Üì\n  Uses SDK              Has Policy\n      ‚Üì                           ‚Üì\n  Gets temp creds         Allows S3 access\n      ‚Üì\n  Accesses S3 Bucket\n```\n\nCreating and Attaching Role:\n\nAWS Console:\n```\n1. IAM ‚Üí Roles ‚Üí Create role\n2. Select \"AWS service\" ‚Üí EC2\n3. Attach policies or create custom policy\n4. Name the role\n5. EC2 ‚Üí Select instance ‚Üí Actions ‚Üí Security ‚Üí Modify IAM role\n6. Select role ‚Üí Update IAM role\n```\n\nAWS CLI:\n```bash\n# Create role\naws iam create-role \\\n  --role-name MyEC2Role \\\n  --assume-role-policy-document file://trust-policy.json\n\n# Attach policy\naws iam attach-role-policy \\\n  --role-name MyEC2Role \\\n  --policy-arn arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess\n\n# Attach role to instance\naws ec2 associate-iam-instance-profile \\\n  --instance-id i-1234567890abcdef0 \\\n  --iam-instance-profile Name=MyEC2Role\n```\n\nCommon Mistake:\n\nConfusing IAM User vs IAM Role:\n‚Ä¢ IAM User: For humans (long-term credentials)\n‚Ä¢ IAM Role: For services (temporary credentials)\n\nFor EC2 ‚Üí Always use IAM Role!\n\nOther AWS Services Using Roles:\n\n‚Ä¢ Lambda ‚Üí IAM execution role\n‚Ä¢ ECS Task ‚Üí Task role\n‚Ä¢ Fargate ‚Üí Task execution role\n‚Ä¢ CodeBuild ‚Üí Service role\n‚Ä¢ CloudFormation ‚Üí Service role\n‚Ä¢ EC2 ‚Üí Instance role\n\nSecurity Best Practices:\n\n‚úì Use IAM roles for ALL AWS service access\n‚úì Follow least privilege principle\n‚úì Regular review role permissions\n‚úì Use managed policies when possible\n‚úì Monitor usage with CloudTrail\n‚úì Never hardcode credentials\n‚úì Never commit credentials to Git\n‚úì Use AWS Secrets Manager for non-AWS secrets\n\nExample Policy (Least Privilege):\n\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Action\": [\n      \"s3:GetObject\"  // Only read, not write\n    ],\n    \"Resource\": [\n      \"arn:aws:s3:::my-bucket/uploads/*\"  // Only specific path\n    ],\n    \"Condition\": {\n      \"IpAddress\": {\n        \"aws:SourceIp\": \"10.0.0.0/8\"  // Only from VPC\n      }\n    }\n  }]\n}\n```\n\nExam Tips:\n‚Ä¢ EC2 accessing AWS services ‚Üí IAM Role (always!)\n‚Ä¢ Never store credentials in code or files\n‚Ä¢ IAM roles provide temporary credentials\n‚Ä¢ Credentials auto-rotate hourly\n‚Ä¢ EC2 metadata service provides credentials\n‚Ä¢ Most secure and recommended method\n‚Ä¢ Works with AWS SDK automatically",
                explanations: {
                    "Store AWS credentials in the application code": "Incorrect. Hardcoding credentials is a major security risk.",
                    "Attach an IAM role to the EC2 instance": "Correct! IAM roles automatically provide temporary credentials to EC2 instances securely.",
                    "Use environment variables to store access keys": "Incorrect. While better than hardcoding, this still requires managing long-term credentials.",
                    "Create an IAM user and store credentials in a file": "Incorrect. This requires managing and rotating credentials manually."
                }
            },
            {
                id: 23,
                domain: "Security",
                type: "Multiple Choice",
                question: "Which service should be used to store database connection strings securely?",
                options: [
                    { text: "Amazon S3", correct: false },
                    { text: "AWS Systems Manager Parameter Store", correct: true },
                    { text: "Amazon DynamoDB", correct: false },
                    { text: "AWS CloudFormation", correct: false }
                ],
                materials: "AWS Systems Manager Parameter Store:\n\nStore database connection strings, API keys, passwords securely.\n\n‚úì Centralized configuration management\n‚úì Encrypted storage (KMS)\n‚úì Version history\n‚úì Fine-grained IAM access control\n‚úì Integration with AWS services\n‚úì Free tier available\n\nParameter Store vs Other Options:\n\n1. Parameter Store ‚úì\n   ‚Ä¢ Designed for configuration + secrets\n   ‚Ä¢ KMS encryption\n   ‚Ä¢ Hierarchical organization\n   ‚Ä¢ Version tracking\n   ‚Ä¢ Free for standard parameters\n   ‚Ä¢ $0.05 per advanced parameter\n\n2. Secrets Manager ‚úì\n   ‚Ä¢ Designed specifically for secrets\n   ‚Ä¢ Automatic rotation\n   ‚Ä¢ More features than Parameter Store\n   ‚Ä¢ $0.40 per secret/month\n   ‚Ä¢ $0.05 per 10,000 API calls\n   ‚Ä¢ Best for passwords that need rotation\n\n3. S3 ‚ùå\n   ‚Ä¢ Object storage\n   ‚Ä¢ Not designed for secrets\n   ‚Ä¢ Manual encryption management\n   ‚Ä¢ No built-in rotation\n   ‚Ä¢ Access patterns not optimized\n\n4. DynamoDB ‚ùå\n   ‚Ä¢ Database service\n   ‚Ä¢ Not designed for secrets\n   ‚Ä¢ Requires custom encryption\n   ‚Ä¢ Overkill for simple config\n\n5. CloudFormation ‚ùå\n   ‚Ä¢ Infrastructure as code\n   ‚Ä¢ Not a storage service\n   ‚Ä¢ Can reference Parameter Store\n\nParameter Store Example:\n\n```python\nimport boto3\n\nssm = boto3.client('ssm')\n\n# Store connection string\nssm.put_parameter(\n    Name='/myapp/prod/db-connection',\n    Value='postgresql://user:pass@db.example.com:5432/mydb',\n    Type='SecureString',  # Encrypted with KMS\n    Description='Production database connection'\n)\n\n# Retrieve in application\nresponse = ssm.get_parameter(\n    Name='/myapp/prod/db-connection',\n    WithDecryption=True  # Decrypt the value\n)\nconnection_string = response['Parameter']['Value']\n```\n\nParameter Types:\n\n1. String (plain text)\n2. StringList (comma-separated)\n3. SecureString (encrypted)\n\nBest for secrets: SecureString!\n\nHierarchical Organization:\n```\n/myapp/\n  /prod/\n    /db-connection\n    /api-key\n    /redis-url\n  /dev/\n    /db-connection\n    /api-key\n```\n\nExam Tip: Parameter Store or Secrets Manager for secure config storage!",
                explanations: {
                    "Amazon S3": "Incorrect. S3 is for object storage, not designed for secrets management.",
                    "AWS Systems Manager Parameter Store": "Correct! Parameter Store (or Secrets Manager) is designed for storing sensitive configuration data securely with encryption.",
                    "Amazon DynamoDB": "Incorrect. DynamoDB is a database, not a secrets management service.",
                    "AWS CloudFormation": "Incorrect. CloudFormation is for infrastructure as code, not storing secrets."
                }
            },
            {
                id: 24,
                domain: "Security",
                type: "Multiple Response",
                question: "Which actions improve Lambda function security? (Select TWO)",
                options: [
                    { text: "Use environment variables for sensitive data", correct: false },
                    { text: "Encrypt environment variables using KMS", correct: true },
                    { text: "Grant the function administrator access", correct: false },
                    { text: "Apply the principle of least privilege to IAM roles", correct: true },
                    { text: "Store credentials in the function code", correct: false }
                ],
                materials: "Lambda Security Best Practices:\n\n1. Encrypt Environment Variables with KMS ‚úì\n‚Ä¢ Lambda env vars visible in console by default\n‚Ä¢ Use KMS to encrypt sensitive values\n‚Ä¢ Decrypted at runtime automatically\n‚Ä¢ Prevents console/API exposure\n\n2. Apply Least Privilege to IAM Roles ‚úì\n‚Ä¢ Grant only needed permissions\n‚Ä¢ Avoid `*` permissions\n‚Ä¢ Use specific actions and resources\n‚Ä¢ Review permissions regularly\n\n‚ùå Bad IAM Policy:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"*\",  // Everything!\n  \"Resource\": \"*\"  // Everywhere!\n}\n```\n\n‚úì Good IAM Policy:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": [\"s3:GetObject\"],\n  \"Resource\": \"arn:aws:s3:::my-bucket/*\"\n}\n```\n\nOther Security Measures:\n‚Ä¢ Use Secrets Manager for credentials\n‚Ä¢ Enable X-Ray tracing (not security logs)\n‚Ä¢ Deploy in VPC when accessing private resources\n‚Ä¢ Use Lambda layers for shared security code\n‚Ä¢ Regular dependency updates\n‚Ä¢ Code scanning for vulnerabilities\n\nExam Tip: KMS encryption + Least privilege = Security!",
                explanations: {
                    "Use environment variables for sensitive data": "Partially correct but incomplete. Environment variables should be encrypted.",
                    "Encrypt environment variables using KMS": "Correct! KMS encryption protects sensitive data in environment variables.",
                    "Grant the function administrator access": "Incorrect. This violates least privilege principles.",
                    "Apply the principle of least privilege to IAM roles": "Correct! Functions should only have permissions they actually need.",
                    "Store credentials in the function code": "Incorrect. This is a critical security vulnerability."
                }
            },
            {
                id: 25,
                domain: "Security",
                type: "Multiple Choice",
                question: "A developer wants to ensure API Gateway endpoints are only accessible to authenticated users. Which feature should be implemented?",
                options: [
                    { text: "CORS configuration", correct: false },
                    { text: "Lambda authorizer or Cognito authorizer", correct: true },
                    { text: "VPC endpoint", correct: false },
                    { text: "CloudFront distribution", correct: false }
                ],
                materials: "API Gateway Authentication/Authorization:\n\nOptions for Securing API Endpoints:\n\n1. Lambda Authorizer (Custom Authorizer) ‚úì\n‚Ä¢ Custom authentication logic\n‚Ä¢ Validate tokens (JWT, OAuth)\n‚Ä¢ Return IAM policy\n‚Ä¢ Flexible for any auth system\n‚Ä¢ Cache results for performance\n\n2. Cognito User Pool Authorizer ‚úì\n‚Ä¢ AWS-managed user authentication\n‚Ä¢ Built-in user management\n‚Ä¢ OAuth 2.0 / OpenID Connect\n‚Ä¢ No custom code needed\n‚Ä¢ Handles token validation\n\n3. AWS_IAM Authorization\n‚Ä¢ SigV4 signing\n‚Ä¢ For service-to-service\n‚Ä¢ Uses IAM policies\n\n‚ùå Not for Authentication:\n‚Ä¢ CORS: Cross-origin settings\n‚Ä¢ VPC Endpoint: Network isolation\n‚Ä¢ CloudFront: CDN\n\nExample Lambda Authorizer:\n```python\ndef lambda_handler(event, context):\n    token = event['authorizationToken']\n    \n    if validate_token(token):\n        return generate_allow_policy()\n    else:\n        return generate_deny_policy()\n```\n\nExam Tip: User authentication ‚Üí Cognito or Lambda authorizer!",
                explanations: {
                    "CORS configuration": "Incorrect. CORS controls cross-origin requests, not authentication.",
                    "Lambda authorizer or Cognito authorizer": "Correct! These provide authentication and authorization for API requests.",
                    "VPC endpoint": "Incorrect. VPC endpoints control network access, not user authentication.",
                    "CloudFront distribution": "Incorrect. CloudFront is for content delivery, not authentication."
                }
            },
            {
                id: 26,
                domain: "Security",
                type: "Multiple Choice",
                question: "What is the purpose of AWS KMS Customer Master Keys (CMKs)?",
                options: [
                    { text: "To manage user passwords", correct: false },
                    { text: "To encrypt and decrypt data", correct: true },
                    { text: "To authenticate API requests", correct: false },
                    { text: "To rotate IAM access keys", correct: false }
                ],
                materials: "AWS KMS (Key Management Service):\n\nPurpose: Encryption Key Management\n\nCustomer Master Keys (CMKs) now called KMS Keys:\n‚Ä¢ Create and manage encryption keys\n‚Ä¢ Encrypt/decrypt data\n‚Ä¢ Keys never leave KMS unencrypted\n‚Ä¢ Integrated with most AWS services\n\nCommon Uses:\n‚Ä¢ S3 bucket encryption (SSE-KMS)\n‚Ä¢ EBS volume encryption\n‚Ä¢ RDS database encryption\n‚Ä¢ Lambda environment variables\n‚Ä¢ Secrets Manager encryption\n‚Ä¢ DynamoDB encryption\n\nKey Types:\n1. AWS Managed: Free, automatic rotation\n2. Customer Managed: You control, $1/month\n3. AWS Owned: Used by AWS, no cost\n\nEncryption Example:\n```python\nimport boto3\n\nkms = boto3.client('kms')\n\n# Encrypt data\nresponse = kms.encrypt(\n    KeyId='alias/my-key',\n    Plaintext='sensitive data'\n)\nencrypted = response['CiphertextBlob']\n\n# Decrypt data\nresponse = kms.decrypt(\n    CiphertextBlob=encrypted\n)\nplaintext = response['Plaintext']\n```\n\nBenefits:\n‚Ä¢ Centralized key management\n‚Ä¢ Audit trail (CloudTrail)\n‚Ä¢ Automatic key rotation\n‚Ä¢ Fine-grained access control\n\nExam Tip: KMS = Encryption keys, not passwords or API auth!",
                explanations: {
                    "To manage user passwords": "Incorrect. KMS is for encryption keys, not password management.",
                    "To encrypt and decrypt data": "Correct! CMKs are encryption keys used to protect data at rest and in transit.",
                    "To authenticate API requests": "Incorrect. API authentication uses access keys or roles, not CMKs.",
                    "To rotate IAM access keys": "Incorrect. Access key rotation is separate from KMS key management."
                }
            },
            {
                id: 27,
                domain: "Security",
                type: "Multiple Choice",
                question: "A developer needs to allow cross-account access to an S3 bucket. What should be configured?",
                options: [
                    { text: "S3 bucket policy", correct: true },
                    { text: "S3 lifecycle policy", correct: false },
                    { text: "S3 replication rule", correct: false },
                    { text: "S3 CORS configuration", correct: false }
                ],
                materials: "S3 Cross-Account Access:\n\nUse S3 Bucket Policy to grant another AWS account access.\n\nExample Bucket Policy:\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Principal\": {\n      \"AWS\": \"arn:aws:iam::123456789012:root\"  // Other account\n    },\n    \"Action\": [\n      \"s3:GetObject\",\n      \"s3:PutObject\"\n    ],\n    \"Resource\": \"arn:aws:s3:::my-bucket/*\"\n  }]\n}\n```\n\nBucket Policy vs Other Options:\n\n‚úì Bucket Policy: Cross-account access control\n‚ùå Lifecycle Policy: Object transitions/expiration\n‚ùå Replication Rule: Copy objects between buckets\n‚ùå CORS: Browser cross-origin requests\n\nCross-Account Access Pattern:\n```\nAccount A (bucket owner):\n1. Create S3 bucket\n2. Add bucket policy allowing Account B\n\nAccount B (accessing account):\n1. IAM user/role with S3 permissions\n2. Access bucket using Account A's bucket name\n```\n\nExam Tip: Cross-account S3 access = Bucket policy!",
                explanations: {
                    "S3 bucket policy": "Correct! Bucket policies can grant cross-account access by specifying the other account's ARN in the policy.",
                    "S3 lifecycle policy": "Incorrect. Lifecycle policies manage object transitions and expiration, not access control.",
                    "S3 replication rule": "Incorrect. Replication copies objects between buckets, not access control.",
                    "S3 CORS configuration": "Incorrect. CORS controls browser-based cross-origin requests, not cross-account access."
                }
            },
            {
                id: 28,
                domain: "Security",
                type: "Multiple Response",
                question: "Which AWS services help detect security threats? (Select TWO)",
                options: [
                    { text: "AWS GuardDuty", correct: true },
                    { text: "AWS Config", correct: false },
                    { text: "AWS Secrets Manager", correct: false },
                    { text: "Amazon Inspector", correct: true },
                    { text: "AWS CloudTrail", correct: false }
                ],
                materials: "AWS Security Threat Detection Services:\n\n1. AWS GuardDuty ‚úì\n‚Ä¢ Intelligent threat detection\n‚Ä¢ Monitors: VPC Flow Logs, CloudTrail, DNS logs\n‚Ä¢ Uses ML to detect anomalies\n‚Ä¢ Identifies: Compromised instances, reconnaissance, malicious IPs\n‚Ä¢ Continuous monitoring\n‚Ä¢ Findings in console\n\n2. Amazon Inspector ‚úì\n‚Ä¢ Automated security assessment\n‚Ä¢ Scans: EC2, Lambda, Container images\n‚Ä¢ Finds: Vulnerabilities, network exposure\n‚Ä¢ CVE database checks\n‚Ä¢ Best practice deviations\n‚Ä¢ Risk scores and remediation\n\n‚ùå Not Threat Detection:\n‚Ä¢ AWS Config: Resource configuration tracking\n‚Ä¢ Secrets Manager: Store/rotate secrets\n‚Ä¢ CloudTrail: API call logging (input for GuardDuty)\n\nComparison:\n```\nGuardDuty: Real-time threat detection (active attacks)\nInspector: Vulnerability assessment (potential weaknesses)\n```\n\nExam Tip: Threat detection ‚Üí GuardDuty + Inspector!",
                explanations: {
                    "AWS GuardDuty": "Correct! GuardDuty continuously monitors for malicious activity and unauthorized behavior using ML.",
                    "AWS Config": "Incorrect. Config tracks resource configurations and compliance, not active threat detection.",
                    "AWS Secrets Manager": "Incorrect. Secrets Manager stores and rotates secrets, doesn't detect threats.",
                    "Amazon Inspector": "Correct! Inspector automatically assesses applications for vulnerabilities and deviations from best practices.",
                    "AWS CloudTrail": "Incorrect. CloudTrail logs API calls for auditing but doesn't actively detect threats (though GuardDuty analyzes CloudTrail logs)."
                }
            },
            {
                id: 29,
                domain: "Security",
                type: "Multiple Choice",
                question: "What is the AWS Shared Responsibility Model's customer responsibility?",
                options: [
                    { text: "Physical security of data centers", correct: false },
                    { text: "Security configurations of AWS services they use", correct: true },
                    { text: "Maintaining hypervisor software", correct: false },
                    { text: "Hardware maintenance", correct: false }
                ],
                materials: "AWS Shared Responsibility Model:\n\nAWS Responsibility (Security OF the cloud):\n‚Ä¢ Physical data center security\n‚Ä¢ Hardware infrastructure\n‚Ä¢ Network infrastructure\n‚Ä¢ Virtualization layer (hypervisor)\n‚Ä¢ Managed service operations\n\nCustomer Responsibility (Security IN the cloud):\n‚Ä¢ Data encryption\n‚Ä¢ Operating system patches\n‚Ä¢ Network configuration (security groups, NACLs)\n‚Ä¢ IAM user/role management\n‚Ä¢ Application code security\n‚Ä¢ Firewall configuration\n‚Ä¢ Data classification\n\nSimple Rule:\n‚Ä¢ Can you configure it? ‚Üí You're responsible\n‚Ä¢ AWS managed infrastructure? ‚Üí AWS responsible\n\nExamples:\n‚Ä¢ S3: AWS secures infrastructure, you configure bucket policies\n‚Ä¢ EC2: AWS secures host, you secure OS and apps\n‚Ä¢ Lambda: AWS secures everything except your code\n\nExam Tip: Customer = Configuration & Data security!",
                explanations: {
                    "Physical security of data centers": "Incorrect. AWS manages physical infrastructure security.",
                    "Security configurations of AWS services they use": "Correct! Customers are responsible for security IN the cloud: data, applications, IAM, OS, network config, encryption.",
                    "Maintaining hypervisor software": "Incorrect. AWS manages the virtualization layer.",
                    "Hardware maintenance": "Incorrect. AWS maintains all physical hardware."
                }
            },
            {
                id: 30,
                domain: "Security",
                type: "Multiple Choice",
                question: "A developer needs to enforce MFA for API calls to critical resources. Where should this be configured?",
                options: [
                    { text: "In the application code", correct: false },
                    { text: "In IAM policy conditions", correct: true },
                    { text: "In CloudWatch Logs", correct: false },
                    { text: "In VPC security groups", correct: false }
                ],
                materials: "Enforcing MFA for API Calls:\n\nUse IAM Policy Conditions to require MFA for critical operations.\n\nExample Policy with MFA Requirement:\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Action\": \"s3:DeleteBucket\",\n    \"Resource\": \"*\",\n    \"Condition\": {\n      \"Bool\": {\n        \"aws:MultiFactorAuthPresent\": \"true\"  // MFA required!\n      }\n    }\n  }]\n}\n```\n\nHow It Works:\n‚Ä¢ User must have MFA device configured\n‚Ä¢ When making API call, must provide MFA token\n‚Ä¢ AWS validates MFA before allowing action\n‚Ä¢ If no MFA ‚Üí Access denied\n\nCommon MFA Conditions:\n‚Ä¢ `aws:MultiFactorAuthPresent`: true/false\n‚Ä¢ `aws:MultiFactorAuthAge`: Max age in seconds\n\nUse Cases:\n‚Ä¢ Deleting resources\n‚Ä¢ Changing security settings\n‚Ä¢ Accessing sensitive data\n‚Ä¢ Production deployments\n\nExam Tip: MFA enforcement = IAM policy conditions!",
                explanations: {
                    "In the application code": "Incorrect. MFA enforcement is an IAM concern, not application logic.",
                    "In IAM policy conditions": "Correct! IAM policies can include conditions like 'aws:MultiFactorAuthPresent' to require MFA.",
                    "In CloudWatch Logs": "Incorrect. CloudWatch Logs is for logging, not access control.",
                    "In VPC security groups": "Incorrect. Security groups control network traffic, not MFA."
                }
            },
            {
                id: 31,
                domain: "Security",
                type: "Multiple Choice",
                question: "Which encryption method does AWS use for data at rest in S3 by default?",
                options: [
                    { text: "No encryption", correct: false },
                    { text: "Server-side encryption with S3-managed keys (SSE-S3)", correct: true },
                    { text: "Client-side encryption", correct: false },
                    { text: "Encryption must be manually enabled", correct: false }
                ],
                materials: "S3 Default Encryption (As of 2023):\n\n‚úì ALL new S3 objects automatically encrypted\n‚úì Uses SSE-S3 (Server-Side Encryption with S3-Managed Keys)\n‚úì No configuration needed\n‚úì No additional cost\n‚úì Transparent to applications\n\nEncryption Options:\n1. SSE-S3 (default): S3 manages keys\n2. SSE-KMS: Customer-managed KMS keys\n3. SSE-C: Customer-provided keys\n4. Client-side: Encrypt before upload\n\nExam Tip: S3 default encryption = SSE-S3 (automatic)",
                explanations: {
                    "No encryption": "Incorrect. As of 2023, S3 automatically encrypts all new objects.",
                    "Server-side encryption with S3-managed keys (SSE-S3)": "Correct! S3 automatically applies SSE-S3 encryption to all new objects by default.",
                    "Client-side encryption": "Incorrect. While possible, this isn't the default. The application must handle client-side encryption.",
                    "Encryption must be manually enabled": "Incorrect. Encryption is now enabled by default."
                }
            },
            {
                id: 32,
                domain: "Security",
                type: "Multiple Choice",
                question: "A company wants to audit all API calls made in their AWS account. Which service should they enable?",
                options: [
                    { text: "AWS Config", correct: false },
                    { text: "AWS CloudTrail", correct: true },
                    { text: "Amazon CloudWatch", correct: false },
                    { text: "AWS X-Ray", correct: false }
                ],
                materials: "AWS CloudTrail - API Audit Logging:\n\nPurpose: Log ALL AWS API calls for audit\n\nWhat CloudTrail Captures:\n‚Ä¢ Who: IAM user/role making the call\n‚Ä¢ When: Timestamp\n‚Ä¢ Where: Source IP address\n‚Ä¢ What: API action (e.g., s3:PutObject)\n‚Ä¢ Resource: Affected AWS resource\n‚Ä¢ Response: Success or error\n\nUse Cases:\n‚Ä¢ Security analysis\n‚Ä¢ Compliance auditing\n‚Ä¢ Operational troubleshooting\n‚Ä¢ Forensic investigation\n‚Ä¢ Change tracking\n\nNot CloudTrail:\n‚Ä¢ Config: Resource configuration changes\n‚Ä¢ CloudWatch: Metrics and logs\n‚Ä¢ X-Ray: Application tracing\n\nExam Tip: API call auditing = CloudTrail!",
                explanations: {
                    "AWS Config": "Incorrect. Config tracks resource configuration changes, not all API calls.",
                    "AWS CloudTrail": "Correct! CloudTrail records all API calls including who made them, when, and from where.",
                    "Amazon CloudWatch": "Incorrect. CloudWatch monitors metrics and logs but doesn't provide API audit trails.",
                    "AWS X-Ray": "Incorrect. X-Ray traces application requests, not AWS API calls."
                }
            },
            {
                id: 33,
                domain: "Security",
                type: "Multiple Response",
                question: "Which statements about IAM roles are true? (Select TWO)",
                options: [
                    { text: "Roles have long-term credentials", correct: false },
                    { text: "Roles provide temporary security credentials", correct: true },
                    { text: "Roles can be assumed by users, applications, or services", correct: true },
                    { text: "Roles require a password", correct: false },
                    { text: "Roles are region-specific", correct: false }
                ],
                materials: "IAM Roles - Key Characteristics:\n\n‚úì Provide temporary security credentials\n‚Ä¢ Auto-rotate credentials\n‚Ä¢ Expire after session duration\n‚Ä¢ More secure than static keys\n\n‚úì Can be assumed by:\n‚Ä¢ IAM users (same or different account)\n‚Ä¢ AWS services (EC2, Lambda, ECS)\n‚Ä¢ External identities (SAML, OIDC)\n‚Ä¢ Applications\n\n‚úì Global resource (not region-specific)\n‚úì No password required\n‚úì Defined by trust policy\n\nBenefits:\n‚Ä¢ No long-term credentials to manage\n‚Ä¢ Automatic rotation\n‚Ä¢ Centralized permission management\n‚Ä¢ Cross-account access\n\nExam Tip: Roles = Temporary credentials + Assumable",
                explanations: {
                    "Roles have long-term credentials": "Incorrect. Roles provide temporary credentials that expire.",
                    "Roles provide temporary security credentials": "Correct! Roles generate temporary credentials with automatic rotation.",
                    "Roles can be assumed by users, applications, or services": "Correct! Roles can be assumed by various entities defined in the trust policy.",
                    "Roles require a password": "Incorrect. Roles use temporary security tokens, not passwords.",
                    "Roles are region-specific": "Incorrect. IAM roles are global resources."
                }
            },
            {
                id: 34,
                domain: "Security",
                type: "Multiple Choice",
                question: "What is the maximum validity period for IAM role temporary credentials?",
                options: [
                    { text: "1 hour", correct: false },
                    { text: "12 hours", correct: true },
                    { text: "24 hours", correct: false },
                    { text: "7 days", correct: false }
                ],
                materials: "IAM Role Session Duration:\n\nMaximum: 12 hours\n\nDefault Durations:\n‚Ä¢ Console: 1 hour\n‚Ä¢ Programmatic (AssumeRole): 1 hour (configurable)\n‚Ä¢ EC2 instance role: Credentials refreshed before expiry\n\nConfiguration:\n‚Ä¢ Set max session duration when creating role (1-12 hours)\n‚Ä¢ Specify duration when assuming role (up to max)\n‚Ä¢ Can't exceed role's max session duration setting\n\nExample:\n```bash\naws sts assume-role \\\n  --role-arn arn:aws:iam::123:role/MyRole \\\n  --role-session-name session1 \\\n  --duration-seconds 43200  # 12 hours\n```\n\nExam Tip: Max IAM role session = 12 hours!",
                explanations: {
                    "1 hour": "Incorrect. Credentials can last longer than this.",
                    "12 hours": "Correct! IAM role session duration can be configured up to 12 hours maximum.",
                    "24 hours": "Incorrect. This exceeds the maximum duration.",
                    "7 days": "Incorrect. This far exceeds the maximum duration."
                }
            },
            {
                id: 35,
                domain: "Security",
                type: "Multiple Choice",
                question: "A developer wants to restrict S3 bucket access to specific VPC endpoints only. What should be configured?",
                options: [
                    { text: "S3 bucket policy with VPC endpoint condition", correct: true },
                    { text: "VPC security group", correct: false },
                    { text: "Network ACL", correct: false },
                    { text: "S3 lifecycle policy", correct: false }
                ],
                materials: "S3 VPC Endpoint Access Control:\n\nUse Case: Restrict S3 access to only come from your VPC\n\nBucket Policy with VPC Endpoint Condition:\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Deny\",\n    \"Principal\": \"*\",\n    \"Action\": \"s3:*\",\n    \"Resource\": [\n      \"arn:aws:s3:::my-bucket\",\n      \"arn:aws:s3:::my-bucket/*\"\n    ],\n    \"Condition\": {\n      \"StringNotEquals\": {\n        \"aws:SourceVpce\": \"vpce-12345\"  // VPC endpoint ID\n      }\n    }\n  }]\n}\n```\n\nBenefits:\n‚Ä¢ Data never leaves AWS network\n‚Ä¢ No internet gateway needed\n‚Ä¢ Lower data transfer costs\n‚Ä¢ Enhanced security\n\nExam Tip: VPC-only S3 access = Bucket policy + VPC endpoint condition",
                explanations: {
                    "S3 bucket policy with VPC endpoint condition": "Correct! Use a bucket policy with condition 'aws:SourceVpce' to allow access only from specific VPC endpoints.",
                    "VPC security group": "Incorrect. Security groups don't apply to S3 (it's not in a VPC).",
                    "Network ACL": "Incorrect. NACLs control VPC subnet traffic, not S3 access control.",
                    "S3 lifecycle policy": "Incorrect. Lifecycle policies manage object retention, not access control."
                }
            },
            {
                id: 36,
                domain: "Security",
                type: "Multiple Choice",
                question: "What is the purpose of Amazon Cognito User Pools?",
                options: [
                    { text: "To create and maintain a user directory for authentication", correct: true },
                    { text: "To encrypt data at rest", correct: false },
                    { text: "To monitor application performance", correct: false },
                    { text: "To manage AWS IAM users", correct: false }
                ],
                materials: "Amazon Cognito User Pools:\n\nPurpose: Managed user directory + authentication for apps\n\nFeatures:\n‚Ä¢ User registration and sign-in\n‚Ä¢ Email/phone verification\n‚Ä¢ Password policies and resets\n‚Ä¢ MFA support\n‚Ä¢ OAuth 2.0 / OpenID Connect\n‚Ä¢ Social identity providers (Google, Facebook)\n‚Ä¢ SAML federation\n‚Ä¢ Customizable UI\n‚Ä¢ User profile attributes\n\nUse Cases:\n‚Ä¢ Mobile app authentication\n‚Ä¢ Web app user management\n‚Ä¢ API Gateway authorizer\n‚Ä¢ Custom application auth\n\nCognito Components:\n1. User Pools: User directory + auth\n2. Identity Pools: AWS credentials for users\n\nNot Cognito:\n‚Ä¢ IAM: AWS resource access (not app users)\n‚Ä¢ KMS: Encryption\n‚Ä¢ CloudWatch: Monitoring\n\nExam Tip: App user authentication ‚Üí Cognito User Pools!",
                explanations: {
                    "To create and maintain a user directory for authentication": "Correct! User Pools handle user registration, authentication, password reset, and account management.",
                    "To encrypt data at rest": "Incorrect. Cognito is for authentication, not encryption (use KMS for encryption).",
                    "To monitor application performance": "Incorrect. Use CloudWatch or X-Ray for monitoring.",
                    "To manage AWS IAM users": "Incorrect. Cognito manages application users, not IAM users."
                }
            },
            {
                id: 37,
                domain: "Security",
                type: "Multiple Choice",
                question: "A developer needs to detect and prevent SQL injection attacks. Which AWS service can help?",
                options: [
                    { text: "AWS Shield", correct: false },
                    { text: "AWS WAF", correct: true },
                    { text: "AWS GuardDuty", correct: false },
                    { text: "Amazon Inspector", correct: false }
                ],
                materials: "AWS WAF - Web Application Firewall:\n\nPurpose: Protect web apps from common attacks\n\nProtects Against:\n‚Ä¢ SQL injection ‚úì\n‚Ä¢ Cross-site scripting (XSS)\n‚Ä¢ Cross-site request forgery (CSRF)\n‚Ä¢ Bot attacks\n‚Ä¢ IP-based attacks\n‚Ä¢ Rate limiting (DDoS)\n‚Ä¢ Geo-blocking\n\nWorks With:\n‚Ä¢ CloudFront\n‚Ä¢ Application Load Balancer\n‚Ä¢ API Gateway\n‚Ä¢ AppSync\n\nWAF Rules:\n‚Ä¢ Managed rules (AWS/marketplace)\n‚Ä¢ Custom rules (your logic)\n‚Ä¢ Rate-based rules\n‚Ä¢ IP sets\n‚Ä¢ Regex patterns\n\nOther AWS Security:\n‚Ä¢ Shield: DDoS protection\n‚Ä¢ GuardDuty: Threat detection\n‚Ä¢ Inspector: Vulnerability scanning\n\nExam Tip: SQL injection/XSS protection = AWS WAF!",
                explanations: {
                    "AWS Shield": "Incorrect. Shield protects against DDoS attacks, not application-layer exploits.",
                    "AWS WAF": "Correct! WAF provides managed and custom rules to filter malicious requests including SQL injection attempts.",
                    "AWS GuardDuty": "Incorrect. GuardDuty detects threats but doesn't prevent them at the application layer.",
                    "Amazon Inspector": "Incorrect. Inspector assesses application security but doesn't provide runtime protection."
                }
            },
            {
                id: 38,
                domain: "Security",
                type: "Multiple Choice",
                question: "What is the difference between AWS Secrets Manager and Parameter Store?",
                options: [
                    { text: "Secrets Manager supports automatic rotation", correct: true },
                    { text: "Parameter Store is more expensive", correct: false },
                    { text: "Secrets Manager cannot encrypt data", correct: false },
                    { text: "Parameter Store only stores strings", correct: false }
                ],
                materials: "Secrets Manager vs Parameter Store:\n\nKey Difference: Automatic Rotation\n\nSecrets Manager:\n‚úì Automatic secret rotation (RDS, Redshift, DocumentDB)\n‚úì Custom rotation via Lambda\n‚úì Built-in integration with databases\n‚úì Cross-account access\n‚Ä¢ Cost: $0.40/secret/month + API calls\n‚Ä¢ Best for: Database credentials, API keys needing rotation\n\nParameter Store:\n‚úì Free for standard parameters\n‚úì Hierarchical organization\n‚úì Parameter policies\n‚Ä¢ Manual rotation only\n‚Ä¢ Cost: Free (standard), $0.05 (advanced)\n‚Ä¢ Best for: Configuration data, connection strings\n\nBoth Support:\n‚Ä¢ KMS encryption\n‚Ä¢ Version tracking\n‚Ä¢ IAM access control\n‚Ä¢ Integration with AWS services\n\nExam Tip: Automatic rotation = Secrets Manager!",
                explanations: {
                    "Secrets Manager supports automatic rotation": "Correct! Secrets Manager includes built-in rotation for RDS, Redshift, and DocumentDB, plus custom rotation via Lambda.",
                    "Parameter Store is more expensive": "Incorrect. Parameter Store is free for standard parameters; Secrets Manager charges per secret.",
                    "Secrets Manager cannot encrypt data": "Incorrect. Both services support KMS encryption.",
                    "Parameter Store only stores strings": "Incorrect. Parameter Store stores strings, StringLists, and SecureStrings."
                }
            },
            // DOMAIN 3: Deployment (24% - 16 questions)
            {
                id: 39,
                domain: "Deployment",
                type: "Multiple Choice",
                question: "A developer needs to deploy updates to an Elastic Beanstalk environment with zero downtime. Which deployment policy should be used?",
                options: [
                    { text: "All at once", correct: false },
                    { text: "Rolling", correct: false },
                    { text: "Rolling with additional batch", correct: false },
                    { text: "Immutable", correct: true }
                ],
                materials: "Elastic Beanstalk Deployment Policies:\n\nZero Downtime = Immutable\n\nDeployment Options:\n\n1. All at Once:\n‚Ä¢ Deploy to all instances simultaneously\n‚Ä¢ ‚ùå Downtime during deployment\n‚Ä¢ ‚úì Fastest method\n‚Ä¢ Use for: Dev/test\n\n2. Rolling:\n‚Ä¢ Deploy in batches\n‚Ä¢ ‚ùå Reduced capacity during deployment\n‚Ä¢ ‚ùå Potential downtime if issues\n‚Ä¢ Use for: Non-critical apps\n\n3. Rolling with Additional Batch:\n‚Ä¢ Creates extra instances, then deploys\n‚Ä¢ ‚úì Maintains full capacity\n‚Ä¢ ‚ùå Not truly zero-downtime\n‚Ä¢ Use for: Production with some flexibility\n\n4. Immutable ‚úì:\n‚Ä¢ Creates new ASG with new instances\n‚Ä¢ Deploys to new instances\n‚Ä¢ Switches traffic after health checks\n‚Ä¢ ‚úì Zero downtime guaranteed\n‚Ä¢ ‚úì Easy rollback (switch back)\n‚Ä¢ ‚ùå Most expensive (double resources temporarily)\n‚Ä¢ Use for: Critical production\n\n5. Blue/Green:\n‚Ä¢ Deploy to separate environment\n‚Ä¢ Swap environment URLs\n‚Ä¢ ‚úì Zero downtime\n‚Ä¢ ‚úì Full testing before switch\n\nExam Tip: Zero downtime + Beanstalk = Immutable!",
                explanations: {
                    "All at once": "Incorrect. This deploys to all instances simultaneously, causing downtime.",
                    "Rolling": "Incorrect. Rolling deployment updates batches sequentially, reducing capacity during deployment.",
                    "Rolling with additional batch": "Incorrect. While this maintains capacity, it doesn't guarantee zero downtime if issues occur.",
                    "Immutable": "Correct! Immutable deployment creates a new Auto Scaling group with updated instances, then switches traffic with zero downtime."
                }
            },
            {
                id: 40,
                domain: "Deployment",
                type: "Multiple Choice",
                question: "What is the purpose of AWS CodeDeploy deployment groups?",
                options: [
                    { text: "To group source code repositories", correct: false },
                    { text: "To define sets of instances for deployment", correct: true },
                    { text: "To store deployment artifacts", correct: false },
                    { text: "To manage IAM permissions", correct: false }
                ],
                materials: "CodeDeploy Deployment Groups:\n\nPurpose: Define target instances for deployment\n\nDeployment Group Specifies:\n‚Ä¢ Target instances (EC2, on-prem, Lambda, ECS)\n‚Ä¢ Deployment configuration (strategy)\n‚Ä¢ Load balancer (optional)\n‚Ä¢ Auto Scaling groups\n‚Ä¢ Deployment success criteria\n\nTarget Selection Methods:\n‚Ä¢ EC2 tags (e.g., Environment=Production)\n‚Ä¢ Auto Scaling groups\n‚Ä¢ Manual instance list\n‚Ä¢ On-premises instance tags\n\nExample:\n```\nDeployment Group: \"Production-Web-Servers\"\n‚îú‚îÄ Target: Instances tagged with \"Role=WebServer\"\n‚îú‚îÄ Deployment Config: Half at a time\n‚îú‚îÄ Load Balancer: ALB-Production\n‚îî‚îÄ Success: 90% healthy instances\n```\n\nDeployment Configurations:\n‚Ä¢ AllAtOnce\n‚Ä¢ Half at a Time\n‚Ä¢ OneAtATime\n‚Ä¢ Custom percentages\n\nExam Tip: Deployment group = Target instance definition!",
                explanations: {
                    "To group source code repositories": "Incorrect. CodeCommit manages repositories, not deployment groups.",
                    "To define sets of instances for deployment": "Correct! Deployment groups identify target instances using tags, Auto Scaling groups, or EC2 instances.",
                    "To store deployment artifacts": "Incorrect. S3 or CodeArtifact stores artifacts.",
                    "To manage IAM permissions": "Incorrect. IAM roles manage permissions separately."
                }
            },
            {
                id: 41,
                domain: "Deployment",
                type: "Multiple Response",
                question: "Which AWS services are part of the CI/CD pipeline? (Select TWO)",
                options: [
                    { text: "AWS CodePipeline", correct: true },
                    { text: "AWS Lambda", correct: false },
                    { text: "AWS CodeBuild", correct: true },
                    { text: "Amazon S3", correct: false },
                    { text: "Amazon RDS", correct: false }
                ],
                materials: "AWS CI/CD Services:\n\nCore CI/CD Services:\n\n1. CodePipeline ‚úì - Orchestration\n‚Ä¢ Automates release workflow\n‚Ä¢ Connects all stages\n‚Ä¢ Source ‚Üí Build ‚Üí Test ‚Üí Deploy\n‚Ä¢ Triggers on commits\n\n2. CodeBuild ‚úì - Build & Test\n‚Ä¢ Compiles source code\n‚Ä¢ Runs unit tests\n‚Ä¢ Builds Docker images\n‚Ä¢ Produces artifacts\n\n3. CodeDeploy - Deployment\n‚Ä¢ Deploys to EC2, Lambda, ECS\n‚Ä¢ Blue/Green, Rolling deployments\n\n4. CodeCommit - Source Control\n‚Ä¢ Git repository hosting\n\nSupporting Services:\n‚Ä¢ S3: Artifact storage\n‚Ä¢ Lambda: Custom pipeline actions\n‚Ä¢ RDS: Database (not CI/CD)\n\nExam Tip: CodePipeline + CodeBuild = CI/CD core!",
                explanations: {
                    "AWS CodePipeline": "Correct! CodePipeline orchestrates the CI/CD workflow from source to deployment.",
                    "AWS Lambda": "Incorrect. Lambda can be part of the pipeline as a custom action but isn't a CI/CD service itself.",
                    "AWS CodeBuild": "Correct! CodeBuild compiles source code, runs tests, and produces deployable artifacts.",
                    "Amazon S3": "Incorrect. S3 stores artifacts but isn't a CI/CD service.",
                    "Amazon RDS": "Incorrect. RDS is a database service, not part of CI/CD."
                }
            },
            {
                id: 42,
                domain: "Deployment",
                type: "Multiple Choice",
                question: "A developer wants to roll back a Lambda function deployment. What should they do?",
                options: [
                    { text: "Delete the current version", correct: false },
                    { text: "Update the function alias to point to the previous version", correct: true },
                    { text: "Restore from S3 backup", correct: false },
                    { text: "Redeploy the old code manually", correct: false }
                ],
                materials: "Lambda Rollback Strategy:\n\nBest Method: Update Alias to Previous Version\n\nHow It Works:\n```\nCurrent State:\nPROD alias ‚Üí v2 (has bug)\n\nRollback:\nUpdate PROD alias ‚Üí v1 (stable)\n\nResult: Instant rollback!\n```\n\nWhy This Works:\n‚Ä¢ Aliases are mutable pointers\n‚Ä¢ Versions are immutable\n‚Ä¢ No code upload needed\n‚Ä¢ Takes seconds\n‚Ä¢ No downtime\n\nOther Options (Worse):\n‚ùå Delete version: Can't delete if in use\n‚ùå S3 backup: Not automatic, manual\n‚ùå Redeploy code: Slow, error-prone\n\nExam Tip: Lambda rollback = Update alias!",
                explanations: {
                    "Delete the current version": "Incorrect. Published versions are immutable and cannot be deleted if referenced.",
                    "Update the function alias to point to the previous version": "Correct! Aliases provide a stable endpoint that can be instantly redirected to any version for quick rollbacks.",
                    "Restore from S3 backup": "Incorrect. Lambda doesn't automatically backup to S3; this adds unnecessary complexity.",
                    "Redeploy the old code manually": "Incorrect. This is slow and error-prone compared to using versions and aliases."
                }
            },
            {
                id: 43,
                domain: "Deployment",
                type: "Multiple Choice",
                question: "What file defines the deployment configuration in AWS SAM?",
                options: [
                    { text: "package.json", correct: false },
                    { text: "template.yaml", correct: true },
                    { text: "buildspec.yml", correct: false },
                    { text: "Dockerfile", correct: false }
                ],
                materials: "AWS SAM (Serverless Application Model):\n\nConfiguration File: template.yaml\n\nSAM Template Structure:\n```yaml\nAWSTemplateFormatVersion: '2010-09-09'\nTransform: AWS::Serverless-2016-10-31\n\nResources:\n  MyFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      Handler: index.handler\n      Runtime: python3.9\n      Events:\n        ApiEvent:\n          Type: Api\n          Properties:\n            Path: /hello\n            Method: get\n```\n\nSAM simplifies defining:\n‚Ä¢ Lambda functions\n‚Ä¢ API Gateway\n‚Ä¢ DynamoDB tables\n‚Ä¢ Step Functions\n\nOther Files (Not SAM config):\n‚Ä¢ package.json: Node.js dependencies\n‚Ä¢ buildspec.yml: CodeBuild\n‚Ä¢ Dockerfile: Container images\n\nExam Tip: SAM template = template.yaml!",
                explanations: {
                    "package.json": "Incorrect. This is for Node.js dependencies, not SAM configuration.",
                    "template.yaml": "Correct! SAM uses template.yaml (or template.json) to define Lambda functions, APIs, and other resources.",
                    "buildspec.yml": "Incorrect. This is for CodeBuild build specifications.",
                    "Dockerfile": "Incorrect. Dockerfile is for container images."
                }
            },
            {
                id: 44,
                domain: "Deployment",
                type: "Multiple Choice",
                question: "Which CodeDeploy deployment type minimizes deployment time?",
                options: [
                    { text: "In-place deployment", correct: true },
                    { text: "Blue/Green deployment", correct: false },
                    { text: "Rolling deployment", correct: false },
                    { text: "Canary deployment", correct: false }
                ],
                materials: "CodeDeploy Deployment Types:\n\nFastest = In-Place\n\nDeployment Types Comparison:\n\n1. In-Place (Fastest) ‚úì:\n‚Ä¢ Updates existing instances\n‚Ä¢ No new instances created\n‚Ä¢ Quickest deployment\n‚Ä¢ May have brief downtime\n‚Ä¢ Use for: Speed priority\n\n2. Blue/Green (Safer):\n‚Ä¢ Creates new instances (green)\n‚Ä¢ Switches traffic from old (blue)\n‚Ä¢ Takes longer (provision time)\n‚Ä¢ Zero downtime\n‚Ä¢ Easy rollback\n‚Ä¢ Use for: Safety priority\n\nSpeed Ranking:\n1. In-Place (fastest)\n2. Rolling\n3. Canary\n4. Blue/Green (slowest, but safest)\n\nExam Tip: Minimize time = In-place deployment!",
                explanations: {
                    "In-place deployment": "Correct! In-place updates existing instances directly, making it the fastest but with potential downtime.",
                    "Blue/Green deployment": "Incorrect. Blue/Green is safer but takes longer as it provisions new instances.",
                    "Rolling deployment": "Incorrect. Rolling deploys in batches, taking longer than in-place.",
                    "Canary deployment": "Incorrect. Canary gradually shifts traffic, taking the longest but providing the safest validation."
                }
            },
            {
                id: 45,
                domain: "Deployment",
                type: "Multiple Choice",
                question: "A developer needs to automate building Docker images. Which AWS service should be used?",
                options: [
                    { text: "AWS CodeCommit", correct: false },
                    { text: "AWS CodeBuild", correct: true },
                    { text: "AWS CodeDeploy", correct: false },
                    { text: "Amazon ECR", correct: false }
                ],
                materials: "AWS CodeBuild - Building Docker Images:\n\nCodeBuild ‚úì - Automate Docker builds\n\nbuildspec.yml example:\n```yaml\nversion: 0.2\nphases:\n  pre_build:\n    commands:\n      - echo Logging in to ECR...\n      - aws ecr get-login-password | docker login --username AWS --password-stdin $ECR_URI\n  build:\n    commands:\n      - echo Building Docker image...\n      - docker build -t my-app .\n      - docker tag my-app:latest $ECR_URI/my-app:latest\n  post_build:\n    commands:\n      - echo Pushing image to ECR...\n      - docker push $ECR_URI/my-app:latest\n```\n\nService Roles:\n‚Ä¢ CodeCommit: Source control\n‚Ä¢ CodeBuild: Build images ‚úì\n‚Ä¢ CodeDeploy: Deploy containers\n‚Ä¢ ECR: Store images\n\nExam Tip: Build Docker images = CodeBuild!",
                explanations: {
                    "AWS CodeCommit": "Incorrect. CodeCommit stores source code, doesn't build images.",
                    "AWS CodeBuild": "Correct! CodeBuild can build Docker images using buildspec.yml and push them to ECR.",
                    "AWS CodeDeploy": "Incorrect. CodeDeploy handles deployment, not building.",
                    "Amazon ECR": "Incorrect. ECR stores Docker images, doesn't build them."
                }
            },
            {
                id: 46,
                domain: "Deployment",
                type: "Multiple Response",
                question: "What information must be specified in a CodeDeploy AppSpec file? (Select TWO)",
                options: [
                    { text: "Source code repository URL", correct: false },
                    { text: "File copy locations", correct: true },
                    { text: "Lifecycle event hooks", correct: true },
                    { text: "IAM role ARN", correct: false },
                    { text: "CloudWatch log group", correct: false }
                ],
                materials: "CodeDeploy AppSpec File:\n\nRequired Information:\n\n1. File Copy Locations ‚úì\n```yaml\nfiles:\n  - source: /\n    destination: /var/www/html\n```\n\n2. Lifecycle Event Hooks ‚úì\n```yaml\nhooks:\n  BeforeInstall:\n    - location: scripts/install_dependencies.sh\n  AfterInstall:\n    - location: scripts/start_server.sh\n  ApplicationStart:\n    - location: scripts/validate.sh\n```\n\nLifecycle Events:\n‚Ä¢ ApplicationStop\n‚Ä¢ BeforeInstall\n‚Ä¢ AfterInstall\n‚Ä¢ ApplicationStart\n‚Ä¢ ValidateService\n\nNot in AppSpec:\n‚Ä¢ Source repo URL (in pipeline)\n‚Ä¢ IAM roles (in deployment group)\n‚Ä¢ CloudWatch logs (in deployment group)\n\nExam Tip: AppSpec = Files + Hooks!",
                explanations: {
                    "Source code repository URL": "Incorrect. CodePipeline or CodeBuild handles source integration.",
                    "File copy locations": "Correct! AppSpec specifies which files to copy and where on the target instances.",
                    "Lifecycle event hooks": "Correct! Hooks define scripts to run at specific deployment phases (BeforeInstall, AfterInstall, ApplicationStart, etc.).",
                    "IAM role ARN": "Incorrect. IAM roles are configured in deployment groups, not AppSpec.",
                    "CloudWatch log group": "Incorrect. Logging is configured separately in deployment groups."
                }
            },
            {
                id: 47,
                domain: "Deployment",
                type: "Multiple Choice",
                question: "What is the primary benefit of using Lambda weighted aliases?",
                options: [
                    { text: "Reduced function execution time", correct: false },
                    { text: "Gradual traffic shifting between versions", correct: true },
                    { text: "Automatic scaling", correct: false },
                    { text: "Cost reduction", correct: false }
                ],
                materials: "Lambda Weighted Aliases:\n\nPrimary Benefit: Gradual Traffic Shifting ‚úì\n\nHow Weighted Aliases Work:\n```\nPROD Alias:\n‚îú‚îÄ 90% traffic ‚Üí v1 (stable)\n‚îî‚îÄ 10% traffic ‚Üí v2 (new)\n\nTest v2 with 10% of users\nIf good: Shift to 100% v2\nIf bad: Revert to 100% v1\n```\n\nDeployment Strategies:\n‚Ä¢ Linear: 10% every 10 minutes\n‚Ä¢ Canary: 10% first, then 100%\n‚Ä¢ All-at-once: Immediate 100%\n\nCodeDeploy Integration:\n‚Ä¢ Automates traffic shifting\n‚Ä¢ Monitors CloudWatch alarms\n‚Ä¢ Auto-rollback on errors\n\nBenefits:\n‚Ä¢ Safe production testing\n‚Ä¢ Gradual rollout\n‚Ä¢ Easy rollback\n‚Ä¢ Reduced risk\n\nNot weighted alias benefits:\n‚Ä¢ Execution time (same)\n‚Ä¢ Scaling (automatic anyway)\n‚Ä¢ Cost (same)\n\nExam Tip: Weighted alias = Traffic splitting!",
                explanations: {
                    "Reduced function execution time": "Incorrect. Weighted aliases don't affect execution time.",
                    "Gradual traffic shifting between versions": "Correct! You can route a percentage of traffic to a new version while keeping the rest on the stable version.",
                    "Automatic scaling": "Incorrect. Lambda scales automatically regardless of aliases.",
                    "Cost reduction": "Incorrect. Weighted aliases don't directly reduce costs."
                }
            },
            {
                id: 48,
                domain: "Deployment",
                type: "Multiple Choice",
                question: "Which Elastic Beanstalk deployment policy deploys to new instances without affecting existing capacity?",
                options: [
                    { text: "All at once", correct: false },
                    { text: "Rolling", correct: false },
                    { text: "Rolling with additional batch", correct: true },
                    { text: "Immutable", correct: false }
                ],
                materials: "Beanstalk - Maintaining Full Capacity:\n\nRolling with Additional Batch ‚úì\n\nHow It Works:\n```\n1. Current: 4 instances running\n2. Launch +2 new instances (now 6 total) ‚Üê Maintains capacity\n3. Update 2 old instances\n4. Update 2 more old instances\n5. Terminate 2 extra instances (back to 4)\n```\n\nComparison:\n‚Ä¢ All at Once: Updates all (downtime)\n‚Ä¢ Rolling: Updates in-place (reduced capacity)\n‚Ä¢ Rolling + Batch: Adds instances first ‚úì (full capacity)\n‚Ä¢ Immutable: New ASG entirely\n\nExam Tip: Full capacity during deployment = Rolling with additional batch!",
                explanations: {
                    "All at once": "Incorrect. This updates all instances simultaneously, taking them out of service.",
                    "Rolling": "Incorrect. Rolling updates batches in-place, temporarily reducing capacity.",
                    "Rolling with additional batch": "Correct! This launches new instances first (maintaining full capacity), then updates the original instances in rolling fashion.",
                    "Immutable": "Incorrect. While immutable also creates new instances, it doesn't roll them out in batches."
                }
            },
            {
                id: 49,
                domain: "Deployment",
                type: "Multiple Choice",
                question: "What AWS service manages container images for ECS and Kubernetes?",
                options: [
                    { text: "Amazon ECS", correct: false },
                    { text: "Amazon ECR", correct: true },
                    { text: "AWS Fargate", correct: false },
                    { text: "Amazon EKS", correct: false }
                ],
                materials: "Amazon ECR - Container Registry:\n\nECR ‚úì - Stores and manages container images\n\nContainer Service Roles:\n\n1. ECR (Elastic Container Registry) ‚úì:\n‚Ä¢ Store Docker/OCI images\n‚Ä¢ Private registry\n‚Ä¢ Integrated with IAM\n‚Ä¢ Image scanning\n‚Ä¢ Lifecycle policies\n\n2. ECS (Elastic Container Service):\n‚Ä¢ Run containers\n‚Ä¢ Container orchestration\n‚Ä¢ Pulls images from ECR\n\n3. EKS (Elastic Kubernetes Service):\n‚Ä¢ Managed Kubernetes\n‚Ä¢ Runs containers\n‚Ä¢ Uses ECR for images\n\n4. Fargate:\n‚Ä¢ Serverless compute for containers\n‚Ä¢ No servers to manage\n‚Ä¢ Used with ECS/EKS\n\nWorkflow:\nBuild ‚Üí Push to ECR ‚Üí ECS/EKS pulls ‚Üí Fargate runs\n\nExam Tip: Container image storage = ECR!",
                explanations: {
                    "Amazon ECS": "Incorrect. ECS runs containers but doesn't store images.",
                    "Amazon ECR": "Correct! ECR is AWS's container registry service for storing and managing Docker and OCI images.",
                    "AWS Fargate": "Incorrect. Fargate is a serverless compute engine for containers, not a registry.",
                    "Amazon EKS": "Incorrect. EKS runs Kubernetes but doesn't store images."
                }
            },
            {
                id: 50,
                domain: "Deployment",
                type: "Multiple Choice",
                question: "A CodePipeline stage has failed. What happens to the pipeline?",
                options: [
                    { text: "It continues to the next stage", correct: false },
                    { text: "It stops at the failed stage", correct: true },
                    { text: "It automatically retries indefinitely", correct: false },
                    { text: "It rolls back all previous stages", correct: false }
                ],
                materials: "CodePipeline Failure Behavior:\n\nOn Stage Failure: Pipeline Stops ‚úì\n\nWhat Happens:\n```\nSource ‚Üí Build ‚Üí Test (FAILED) ‚õî\n                        ‚Üì\n                  Pipeline stops here\n                        ‚Üì\n              Deploy stage never runs\n```\n\nWhy This Behavior:\n‚Ä¢ Prevents broken code from reaching production\n‚Ä¢ Fail fast principle\n‚Ä¢ Manual intervention required\n‚Ä¢ Review and fix issues\n‚Ä¢ Retry when ready\n\nWhat Doesn't Happen:\n‚ùå Continue to next stage\n‚ùå Infinite auto-retry\n‚ùå Automatic rollback\n\nResolution:\n1. Fix the issue\n2. Push new commit (auto-trigger)\n   OR\n3. Manually retry failed stage\n\nExam Tip: Pipeline failure = Stops at failed stage!",
                explanations: {
                    "It continues to the next stage": "Incorrect. Pipeline execution stops on failure to prevent deploying broken code.",
                    "It stops at the failed stage": "Correct! The pipeline halts at the failed stage until the issue is resolved or manually retried.",
                    "It automatically retries indefinitely": "Incorrect. Manual intervention or retry is needed after failure.",
                    "It rolls back all previous stages": "Incorrect. CodePipeline doesn't automatically rollback; that requires custom actions or CodeDeploy."
                }
            },
            {
                id: 51,
                domain: "Deployment",
                type: "Multiple Choice",
                question: "What is the purpose of the buildspec.yml file in CodeBuild?",
                options: [
                    { text: "To define deployment targets", correct: false },
                    { text: "To specify build commands and phases", correct: true },
                    { text: "To configure IAM permissions", correct: false },
                    { text: "To store build artifacts", correct: false }
                ],
                materials: "CodeBuild buildspec.yml:\n\nPurpose: Define build commands and phases\n\nBuildspec Structure:\n```yaml\nversion: 0.2\nphases:\n  install:\n    commands:\n      - npm install\n  pre_build:\n    commands:\n      - npm run lint\n  build:\n    commands:\n      - npm run build\n  post_build:\n    commands:\n      - echo Build completed\nartifacts:\n  files:\n    - '**/*'\n  base-directory: build\n```\n\nPhases:\n‚Ä¢ install: Dependencies\n‚Ä¢ pre_build: Before build\n‚Ä¢ build: Main build\n‚Ä¢ post_build: After build\n\nNot buildspec.yml:\n‚Ä¢ Deployment targets (CodeDeploy)\n‚Ä¢ IAM permissions (IAM roles)\n‚Ä¢ Artifacts storage (S3)\n\nExam Tip: buildspec.yml = Build commands!",
                explanations: {
                    "To define deployment targets": "Incorrect. CodeDeploy defines deployment targets.",
                    "To specify build commands and phases": "Correct! buildspec.yml defines phases like install, pre_build, build, post_build with their commands.",
                    "To configure IAM permissions": "Incorrect. IAM roles are configured separately in CodeBuild project settings.",
                    "To store build artifacts": "Incorrect. S3 stores artifacts; buildspec specifies which files are artifacts."
                }
            },
            {
                id: 52,
                domain: "Deployment",
                type: "Multiple Choice",
                question: "A developer needs to deploy a Lambda function with dependencies. What should they create?",
                options: [
                    { text: "A Lambda layer", correct: false },
                    { text: "A deployment package", correct: true },
                    { text: "A CloudFormation stack", correct: false },
                    { text: "An AMI", correct: false }
                ],
                materials: "Lambda with Dependencies:\n\nSolution: Deployment Package ‚úì\n\nWhat is a Deployment Package?\n‚Ä¢ .zip file containing:\n  - Your function code\n  - All dependencies (libraries)\n  - Runtime-specific files\n\nCreating Deployment Package:\n```bash\n# Python example\npip install -r requirements.txt -t .\nzip -r function.zip .\n\n# Node.js example\nnpm install\nzip -r function.zip .\n```\n\nOptions:\n1. Deployment Package ‚úì: Code + dependencies\n2. Lambda Layer: Shared dependencies (reusable)\n3. Both: Code in package, common libs in layer\n\nExam Tip: Function with dependencies = Deployment package!",
                explanations: {
                    "A Lambda layer": "Incorrect. While layers can contain dependencies, you still need to package your function code.",
                    "A deployment package": "Correct! A deployment package is a .zip file containing your code and dependencies.",
                    "A CloudFormation stack": "Incorrect. CloudFormation deploys infrastructure but the Lambda code still needs packaging.",
                    "An AMI": "Incorrect. AMIs are for EC2 instances, not Lambda functions."
                }
            },
            {
                id: 53,
                domain: "Deployment",
                type: "Multiple Choice",
                question: "Which command deploys a SAM application?",
                options: [
                    { text: "sam build && sam deploy", correct: true },
                    { text: "sam init && sam run", correct: false },
                    { text: "sam create && sam start", correct: false },
                    { text: "sam package && sam execute", correct: false }
                ],
                materials: "SAM Deployment Commands:\n\nDeployment: sam build && sam deploy ‚úì\n\nSAM CLI Commands:\n\n1. sam init: Create new project\n2. sam build ‚úì: Prepare for deployment\n3. sam deploy ‚úì: Deploy to AWS\n4. sam local: Test locally\n5. sam validate: Check template\n6. sam logs: View function logs\n\nDeployment Workflow:\n```bash\nsam build    # Builds application\nsam deploy   # Deploys to AWS\n```\n\nWhat sam build does:\n‚Ä¢ Processes template\n‚Ä¢ Installs dependencies\n‚Ä¢ Creates .aws-sam directory\n\nWhat sam deploy does:\n‚Ä¢ Packages application\n‚Ä¢ Uploads to S3\n‚Ä¢ Creates CloudFormation stack\n‚Ä¢ Deploys resources\n\nExam Tip: SAM deployment = build + deploy!",
                explanations: {
                    "sam build && sam deploy": "Correct! 'sam build' prepares the application and dependencies, then 'sam deploy' packages and deploys to AWS.",
                    "sam init && sam run": "Incorrect. 'sam init' creates a new project template; there's no 'sam run' command.",
                    "sam create && sam start": "Incorrect. These commands don't exist in SAM CLI.",
                    "sam package && sam execute": "Incorrect. 'sam package' exists but is legacy; 'execute' doesn't exist."
                }
            },
            {
                id: 54,
                domain: "Deployment",
                type: "Multiple Response",
                question: "Which deployment strategies minimize risk? (Select TWO)",
                options: [
                    { text: "All at once", correct: false },
                    { text: "Blue/Green deployment", correct: true },
                    { text: "Canary deployment", correct: true },
                    { text: "Big bang deployment", correct: false },
                    { text: "Direct production deployment", correct: false }
                ],
                materials: "Low-Risk Deployment Strategies:\n\nMinimize Risk: Blue/Green + Canary ‚úì\n\nSafe Strategies:\n\n1. Blue/Green ‚úì:\n‚Ä¢ Maintain two environments\n‚Ä¢ Switch traffic instantly\n‚Ä¢ Easy rollback (switch back)\n‚Ä¢ Test in production-like environment\n\n2. Canary ‚úì:\n‚Ä¢ Gradual traffic shift\n‚Ä¢ Monitor metrics\n‚Ä¢ Auto-rollback on errors\n‚Ä¢ Test with real users safely\n\nRisky Strategies:\n‚ùå All at Once: Everything simultaneously\n‚ùå Big Bang: Same as all at once\n‚ùå Direct Production: No testing\n\nRisk Ranking (Low to High):\n1. Canary (safest)\n2. Blue/Green\n3. Rolling\n4. All at once (riskiest)\n\nExam Tip: Minimize risk = Blue/Green or Canary!",
                explanations: {
                    "All at once": "Incorrect. This is the riskiest strategy, updating everything simultaneously.",
                    "Blue/Green deployment": "Correct! Blue/Green maintains two environments, allowing instant rollback by switching traffic back.",
                    "Canary deployment": "Correct! Canary gradually shifts traffic to new version while monitoring metrics, automatically rolling back on errors.",
                    "Big bang deployment": "Incorrect. This is synonymous with 'all at once' and carries high risk.",
                    "Direct production deployment": "Incorrect. Deploying directly to production without testing is risky."
                }
            },
            // DOMAIN 4: Troubleshooting and Optimization (18% - 11 questions)
            {
                id: 55,
                domain: "Troubleshooting",
                type: "Multiple Choice",
                question: "A Lambda function is timing out after 3 seconds. How can the developer increase the timeout?",
                options: [
                    { text: "Modify the Lambda function configuration", correct: true },
                    { text: "Change the IAM role", correct: false },
                    { text: "Update the VPC settings", correct: false },
                    { text: "Increase memory allocation", correct: false }
                ],
                materials: "Lambda Timeout Configuration:\n\nFix Timeout: Modify function configuration ‚úì\n\nHow to Increase Timeout:\n```\nAWS Console:\nFunction ‚Üí Configuration ‚Üí General ‚Üí Timeout\nChange from 3s to desired value (max 900s)\n\nAWS CLI:\naws lambda update-function-configuration \\\n  --function-name my-function \\\n  --timeout 30\n```\n\nTimeout Range: 1-900 seconds (15 minutes)\n\nWhat Doesn't Fix Timeout:\n‚ùå IAM role: Permissions, not timeout\n‚ùå VPC settings: Network, not timeout\n‚ùå Memory: Affects speed, not timeout limit\n\nNote: More memory = More CPU = Faster execution\n(Can indirectly help, but doesn't increase limit)\n\nExam Tip: Increase timeout = Modify configuration!",
                explanations: {
                    "Modify the Lambda function configuration": "Correct! You can change the timeout value in the function configuration up to 15 minutes.",
                    "Change the IAM role": "Incorrect. IAM roles control permissions, not execution timeout.",
                    "Update the VPC settings": "Incorrect. VPC settings affect network connectivity, not timeout duration.",
                    "Increase memory allocation": "Incorrect. While more memory provides more CPU and can make functions faster, it doesn't directly increase timeout limits."
                }
            },
            {
                id: 56,
                domain: "Troubleshooting",
                type: "Multiple Choice",
                question: "Which CloudWatch metric indicates Lambda function performance issues?",
                options: [
                    { text: "Invocations", correct: false },
                    { text: "Duration", correct: true },
                    { text: "ConcurrentExecutions", correct: false },
                    { text: "Version", correct: false }
                ],
                materials: "Lambda Performance Metrics:\n\nPerformance Indicator: Duration ‚úì\n\nKey CloudWatch Metrics:\n\n1. Duration ‚úì:\n‚Ä¢ How long function executed\n‚Ä¢ Identifies slow performance\n‚Ä¢ Compare to timeout setting\n‚Ä¢ Optimize if consistently high\n\n2. Invocations:\n‚Ä¢ How many times invoked\n‚Ä¢ Shows usage, not performance\n\n3. ConcurrentExecutions:\n‚Ä¢ Simultaneous instances\n‚Ä¢ Shows scaling, not individual performance\n\n4. Errors:\n‚Ä¢ Failed invocations\n‚Ä¢ Shows reliability, not speed\n\n5. Throttles:\n‚Ä¢ Rejected invocations\n‚Ä¢ Concurrency limit reached\n\nPerformance Troubleshooting:\n‚Ä¢ High Duration? Optimize code or increase memory\n‚Ä¢ Duration near timeout? Increase timeout\n‚Ä¢ Cold starts? Use provisioned concurrency\n\nExam Tip: Performance issues = Duration metric!",
                explanations: {
                    "Invocations": "Incorrect. Invocations show how many times the function ran, not performance.",
                    "Duration": "Correct! Duration shows how long the function took to execute, helping identify performance problems.",
                    "ConcurrentExecutions": "Incorrect. This shows how many instances ran simultaneously, not individual performance.",
                    "Version": "Incorrect. Version is metadata, not a performance metric."
                }
            },
            {
                id: 57,
                domain: "Troubleshooting",
                type: "Multiple Choice",
                question: "A developer needs to debug API Gateway request/response transformation. What should they enable?",
                options: [
                    { text: "CloudTrail logging", correct: false },
                    { text: "CloudWatch Logs", correct: true },
                    { text: "X-Ray tracing", correct: false },
                    { text: "VPC Flow Logs", correct: false }
                ],
                materials: "API Gateway Debugging:\n\nDebug Transformations: CloudWatch Logs ‚úì\n\nEnable CloudWatch Logs:\n```\nAPI Gateway Console:\n‚Üí Stage Settings\n‚Üí Logs/Tracing\n‚Üí Enable CloudWatch Logs\n‚Üí Choose log level (INFO or ERROR)\n```\n\nWhat CloudWatch Logs Shows:\n‚Ä¢ Full request/response payloads\n‚Ä¢ Request/response transformations\n‚Ä¢ Integration requests/responses\n‚Ä¢ Authorizer execution\n‚Ä¢ Mapping templates\n‚Ä¢ Errors and exceptions\n\nOther Tools (Not for Debugging Transformations):\n‚Ä¢ CloudTrail: AWS API calls (who deployed)\n‚Ä¢ X-Ray: Request tracing (performance)\n‚Ä¢ VPC Flow Logs: Network traffic\n\nExam Tip: Debug API Gateway = CloudWatch Logs!",
                explanations: {
                    "CloudTrail logging": "Incorrect. CloudTrail logs API calls to AWS services, not API Gateway request/response data.",
                    "CloudWatch Logs": "Correct! Enable CloudWatch Logs on API Gateway stages to see detailed execution logs and request/response payloads.",
                    "X-Ray tracing": "Incorrect. X-Ray shows request tracing but not detailed request/response transformation logs.",
                    "VPC Flow Logs": "Incorrect. Flow logs capture VPC network traffic, not API Gateway application logs."
                }
            },
            {
                id: 58,
                domain: "Troubleshooting",
                type: "Multiple Response",
                question: "What can cause Lambda function throttling? (Select TWO)",
                options: [
                    { text: "Insufficient memory", correct: false },
                    { text: "Exceeding concurrent execution limit", correct: true },
                    { text: "Exceeding reserved concurrency", correct: true },
                    { text: "Function timeout", correct: false },
                    { text: "Missing IAM permissions", correct: false }
                ],
                materials: "Lambda Throttling Causes:\n\nThrottling = Exceeding Concurrency Limits ‚úì\n\nTwo Causes of Throttling:\n\n1. Exceeding Account Concurrent Execution Limit ‚úì:\n‚Ä¢ Default: 1,000 concurrent executions\n‚Ä¢ All functions share this pool\n‚Ä¢ Can request increase\n\n2. Exceeding Reserved Concurrency ‚úì:\n‚Ä¢ Function-specific limit\n‚Ä¢ Example: Function reserved 100\n‚Ä¢ 101st invocation = throttled\n\nNot Throttling Causes:\n‚ùå Insufficient memory: Out-of-memory error\n‚ùå Function timeout: Timeout error\n‚ùå Missing IAM permissions: Authorization error\n\nConcurrency Example:\n```\nAccount limit: 1,000\nFunction A: 900 concurrent\nFunction B: 150 concurrent\nResult: Function B throttled (900+150 > 1,000)\n```\n\nExam Tip: Throttling = Concurrency limits exceeded!",
                explanations: {
                    "Insufficient memory": "Incorrect. Low memory causes out-of-memory errors, not throttling.",
                    "Exceeding concurrent execution limit": "Correct! AWS accounts have concurrent execution limits. Exceeding this causes throttling.",
                    "Exceeding reserved concurrency": "Correct! If a function has reserved concurrency and exceeds it, additional invocations are throttled.",
                    "Function timeout": "Incorrect. Timeouts are different from throttling; the function ran but took too long.",
                    "Missing IAM permissions": "Incorrect. This causes authorization errors, not throttling."
                }
            },
            {
                id: 59,
                domain: "Troubleshooting",
                type: "Multiple Choice",
                question: "A DynamoDB table is experiencing throttling. What is the FIRST step to resolve this?",
                options: [
                    { text: "Enable auto scaling", correct: true },
                    { text: "Create a Global Secondary Index", correct: false },
                    { text: "Change the partition key", correct: false },
                    { text: "Enable point-in-time recovery", correct: false }
                ],
                materials: "DynamoDB Throttling - First Step:\n\nSolution: Enable Auto Scaling ‚úì\n\nWhat is DynamoDB Auto Scaling?\n‚Ä¢ Automatically adjusts read/write capacity\n‚Ä¢ Based on utilization (target: 70%)\n‚Ä¢ Prevents throttling\n‚Ä¢ Cost-effective\n\nHow to Enable:\n```\nDynamoDB Console:\n‚Üí Table ‚Üí Additional settings\n‚Üí Read/Write capacity ‚Üí Auto scaling\n‚Üí Set target utilization (70%)\n‚Üí Set min/max capacity\n```\n\nWhy First Step:\n‚úì Quick to implement\n‚úì No code changes\n‚úì Automatic adjustment\n‚úì Prevents future throttling\n\nOther Options (Not First Step):\n‚Ä¢ GSI: Different query patterns\n‚Ä¢ Change partition key: Redesign (major change)\n‚Ä¢ PITR: Backup/restore feature\n\nExam Tip: DynamoDB throttling ‚Üí Enable auto scaling first!",
                explanations: {
                    "Enable auto scaling": "Correct! Auto scaling automatically increases capacity when utilization is high, preventing throttling.",
                    "Create a Global Secondary Index": "Incorrect. GSIs help with different query patterns but don't address throttling on the base table.",
                    "Change the partition key": "Incorrect. While hot partitions can cause throttling, changing the key requires recreating the table‚Äînot a first step.",
                    "Enable point-in-time recovery": "Incorrect. PITR is for backup/restore, not performance."
                }
            },
            {
                id: 60,
                domain: "Troubleshooting",
                type: "Multiple Choice",
                question: "How can a developer trace a request across multiple AWS services?",
                options: [
                    { text: "Use CloudWatch Logs", correct: false },
                    { text: "Use AWS X-Ray", correct: true },
                    { text: "Use CloudTrail", correct: false },
                    { text: "Use VPC Flow Logs", correct: false }
                ],
                materials: "Tracing Across Multiple Services:\n\nSolution: AWS X-Ray ‚úì\n\nWhat X-Ray Does:\n‚Ä¢ Traces request path across services\n‚Ä¢ Shows complete flow:\n  API Gateway ‚Üí Lambda ‚Üí DynamoDB ‚Üí SNS\n‚Ä¢ Identifies bottlenecks\n‚Ä¢ Measures service latency\n‚Ä¢ Detects errors\n\nExample Trace:\n```\nUser Request (500ms total)\n‚îú‚îÄ API Gateway (10ms)\n‚îú‚îÄ Lambda Function (200ms)\n‚îÇ  ‚îú‚îÄ DynamoDB Query (150ms)\n‚îÇ  ‚îî‚îÄ S3 GetObject (30ms)\n‚îî‚îÄ Response\n```\n\nOther Tools (Not for Tracing):\n‚Ä¢ CloudWatch Logs: Individual service logs\n‚Ä¢ CloudTrail: AWS API calls\n‚Ä¢ VPC Flow Logs: Network packets\n\nExam Tip: Cross-service tracing = X-Ray!",
                explanations: {
                    "Use CloudWatch Logs": "Incorrect. Logs show events within services but don't automatically trace across services.",
                    "Use AWS X-Ray": "Correct! X-Ray traces requests across Lambda, API Gateway, DynamoDB, and other services, showing the complete request flow.",
                    "Use CloudTrail": "Incorrect. CloudTrail logs AWS API calls, not application request tracing.",
                    "Use VPC Flow Logs": "Incorrect. Flow logs show network traffic, not application-level request tracing."
                }
            },
            {
                id: 61,
                domain: "Troubleshooting",
                type: "Multiple Choice",
                question: "What causes a Lambda function to have a cold start?",
                options: [
                    { text: "Function hasn't been invoked recently", correct: true },
                    { text: "Function has errors", correct: false },
                    { text: "Function is throttled", correct: false },
                    { text: "Function timeout is too short", correct: false }
                ],
                materials: "Lambda Cold Start Cause:\n\nCause: Function Hasn't Been Invoked Recently ‚úì\n\nWhat is a Cold Start?\n‚Ä¢ First invocation after inactivity\n‚Ä¢ AWS must initialize new environment:\n  - Download code\n  - Start runtime\n  - Run init code\n  - Then execute function\n‚Ä¢ Adds latency (100ms - several seconds)\n\nWarm vs Cold:\n```\nWarm Start (fast):\n‚Ä¢ Container already running\n‚Ä¢ Just execute function\n‚Ä¢ Sub-millisecond startup\n\nCold Start (slow):\n‚Ä¢ No container available\n‚Ä¢ Initialize everything first\n‚Ä¢ Extra latency\n```\n\nNot Cold Start Causes:\n‚ùå Function errors: Runtime issue\n‚ùå Throttling: Concurrency limit\n‚ùå Short timeout: Configuration issue\n\nExam Tip: Cold start = Haven't invoked recently!",
                explanations: {
                    "Function hasn't been invoked recently": "Correct! When no warm containers exist, Lambda must create a new execution environment, causing cold start latency.",
                    "Function has errors": "Incorrect. Errors occur during execution, unrelated to cold starts.",
                    "Function is throttled": "Incorrect. Throttling prevents execution; cold start affects execution latency.",
                    "Function timeout is too short": "Incorrect. Timeout duration doesn't cause cold starts."
                }
            },
            {
                id: 62,
                domain: "Troubleshooting",
                type: "Multiple Response",
                question: "How can Lambda function cold starts be reduced? (Select TWO)",
                options: [
                    { text: "Increase memory allocation", correct: false },
                    { text: "Use provisioned concurrency", correct: true },
                    { text: "Reduce deployment package size", correct: true },
                    { text: "Enable X-Ray tracing", correct: false },
                    { text: "Use environment variables", correct: false }
                ],
                materials: "Reducing Lambda Cold Starts:\n\nSolutions: Provisioned Concurrency + Smaller Package ‚úì\n\n1. Provisioned Concurrency ‚úì:\n‚Ä¢ Keeps execution environments warm\n‚Ä¢ Ready to respond immediately\n‚Ä¢ No cold start for provisioned instances\n‚Ä¢ Costs more (always running)\n\n2. Reduce Package Size ‚úì:\n‚Ä¢ Smaller = faster to load\n‚Ä¢ Remove unused dependencies\n‚Ä¢ Use Lambda Layers for common libs\n‚Ä¢ Minimize deployment package\n\nOther Optimizations:\n‚Ä¢ Minimize dependencies\n‚Ä¢ Lazy load non-critical modules\n‚Ä¢ Use compiled languages (Go, Rust)\n‚Ä¢ Keep functions warm (scheduled ping)\n\nNot Cold Start Solutions:\n‚ùå Increase memory: Speeds execution, not init\n‚ùå X-Ray: Measures, doesn't reduce\n‚ùå Environment variables: No impact on cold starts\n\nExam Tip: Reduce cold starts = Provisioned concurrency + Smaller package!",
                explanations: {
                    "Increase memory allocation": "Incorrect. More memory speeds execution but doesn't prevent cold starts.",
                    "Use provisioned concurrency": "Correct! Provisioned concurrency keeps a specified number of execution environments warm and ready.",
                    "Reduce deployment package size": "Correct! Smaller packages load faster during initialization, reducing cold start time.",
                    "Enable X-Ray tracing": "Incorrect. X-Ray helps measure cold starts but doesn't reduce them.",
                    "Use environment variables": "Incorrect. Environment variables don't affect cold start performance."
                }
            },
            {
                id: 63,
                domain: "Troubleshooting",
                type: "Multiple Choice",
                question: "A Lambda function receives '429 TooManyRequestsException'. What does this indicate?",
                options: [
                    { text: "Function has errors", correct: false },
                    { text: "Function is being throttled", correct: true },
                    { text: "Function timed out", correct: false },
                    { text: "Function out of memory", correct: false }
                ],
                materials: "Lambda 429 TooManyRequestsException:\n\nMeaning: Function is Throttled ‚úì\n\nWhat 429 Means:\n‚Ä¢ HTTP status code for rate limiting\n‚Ä¢ Too many requests\n‚Ä¢ Concurrency limit exceeded\n‚Ä¢ Invocations rejected\n\nWhy It Happens:\n```\nScenario:\n‚Ä¢ Account limit: 1,000 concurrent\n‚Ä¢ Current usage: 1,000 concurrent\n‚Ä¢ New invocation arrives\n‚Ä¢ Result: 429 TooManyRequestsException\n```\n\nSolutions:\n‚Ä¢ Request limit increase\n‚Ä¢ Reduce concurrent invocations\n‚Ä¢ Use reserved concurrency wisely\n‚Ä¢ Implement retry with backoff\n\nOther Errors (Not 429):\n‚Ä¢ Function errors: 500 errors\n‚Ä¢ Timeout: Task timed out\n‚Ä¢ Out of memory: Memory exceeded\n\nExam Tip: 429 = Throttling/Rate limiting!",
                explanations: {
                    "Function has errors": "Incorrect. Errors produce different error codes.",
                    "Function is being throttled": "Correct! 429 TooManyRequestsException means invocations exceeded concurrency limits and were throttled.",
                    "Function timed out": "Incorrect. Timeouts produce Task timed out after X seconds errors.",
                    "Function out of memory": "Incorrect. Memory issues produce out-of-memory errors."
                }
            },
            {
                id: 64,
                domain: "Troubleshooting",
                type: "Multiple Choice",
                question: "Which metric helps identify DynamoDB hot partitions?",
                options: [
                    { text: "ConsumedReadCapacityUnits per partition", correct: true },
                    { text: "TableSize", correct: false },
                    { text: "ItemCount", correct: false },
                    { text: "GlobalSecondaryIndexes", correct: false }
                ],
                materials: "DynamoDB Hot Partition Detection:\n\nMetric: ConsumedReadCapacityUnits per Partition ‚úì\n\nWhat is a Hot Partition?\n‚Ä¢ One partition receives most traffic\n‚Ä¢ Causes throttling\n‚Ä¢ Poor performance\n‚Ä¢ Inefficient capacity usage\n\nExample:\n```\nPartition A: 9,000 RCU consumed (hot!)\nPartition B: 500 RCU consumed\nPartition C: 500 RCU consumed\n\nTotal capacity: 10,000 RCU\nBut Partition A throttles!\n```\n\nDetection:\n‚Ä¢ Monitor consumed capacity per partition\n‚Ä¢ High variance = hot partition\n‚Ä¢ CloudWatch Contributor Insights\n\nFixes:\n‚Ä¢ Better partition key design\n‚Ä¢ Add randomness to keys\n‚Ä¢ Use composite keys\n‚Ä¢ Increase provisioned capacity\n\nNot Hot Partition Indicators:\n‚Ä¢ TableSize: Storage, not access\n‚Ä¢ ItemCount: Quantity, not traffic\n‚Ä¢ GSI count: Index configuration\n\nExam Tip: Hot partition = Per-partition capacity metrics!",
                explanations: {
                    "ConsumedReadCapacityUnits per partition": "Correct! Monitoring capacity consumption per partition reveals hot partitions receiving excessive traffic.",
                    "TableSize": "Incorrect. Table size doesn't indicate access patterns or hot partitions.",
                    "ItemCount": "Incorrect. Item count shows data distribution, not access patterns.",
                    "GlobalSecondaryIndexes": "Incorrect. GSI count doesn't relate to hot partitions."
                }
            },
            {
                id: 65,
                domain: "Troubleshooting",
                type: "Multiple Choice",
                question: "A developer needs to test a Lambda function locally before deployment. Which tool should they use?",
                options: [
                    { text: "AWS CloudFormation", correct: false },
                    { text: "AWS SAM CLI", correct: true },
                    { text: "AWS CodeBuild", correct: false },
                    { text: "AWS Cloud9", correct: false }
                ],
                materials: "Local Lambda Testing:\n\nTool: AWS SAM CLI ‚úì\n\nSAM Local Commands:\n\n1. sam local invoke:\n```bash\nsam local invoke MyFunction \\\n  --event events/test-event.json\n```\n‚Ä¢ Test specific function\n‚Ä¢ Provide test event\n‚Ä¢ Uses Docker locally\n\n2. sam local start-api:\n```bash\nsam local start-api\ncurl http://localhost:3000/hello\n```\n‚Ä¢ Start local API Gateway\n‚Ä¢ Test HTTP endpoints\n‚Ä¢ Full API simulation\n\n3. sam local start-lambda:\n```bash\nsam local start-lambda\n```\n‚Ä¢ Lambda endpoint emulation\n‚Ä¢ Test with AWS SDK\n\nRequirements:\n‚Ä¢ Docker installed\n‚Ä¢ SAM template\n‚Ä¢ Function code\n\nOther Tools (Not for Local Testing):\n‚Ä¢ CloudFormation: Deploy, not test locally\n‚Ä¢ CodeBuild: Build in AWS\n‚Ä¢ Cloud9: IDE (not local testing tool)\n\nExam Tip: Local Lambda testing = SAM CLI!",
                explanations: {
                    "AWS CloudFormation": "Incorrect. CloudFormation deploys infrastructure but doesn't provide local testing.",
                    "AWS SAM CLI": "Correct! SAM CLI's 'sam local invoke' and 'sam local start-api' commands test Lambda functions locally.",
                    "AWS CodeBuild": "Incorrect. CodeBuild runs builds in AWS, not locally.",
                    "AWS Cloud9": "Incorrect. Cloud9 is an IDE but not specifically for local Lambda testing."
                }
            }
        ];

        let currentQuestionIndex = 0;
        let userAnswers = [];
        let questionOrder = [];
        let unansweredQuestions = [];
        let touchStartX = 0;
        let touchEndX = 0;
        let touchStartY = 0;
        let touchEndY = 0;
        
        // Timer and activity tracking
        const EXAM_DURATION = 7800; // 130 minutes in seconds
        let examStartTime = null;
        let elapsedTime = 0;
        let timerInterval = null;
        let lastActivityTime = Date.now();
        let activityCheckInterval = null;
        let focusLostTime = null;
        let isPaused = false;

        function shuffle(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Local Storage Functions
        function saveProgress() {
            const progress = {
                currentQuestionIndex,
                userAnswers,
                questionOrder,
                unansweredQuestions,
                elapsedTime,
                examStartTime,
                shuffledOptions: questions.map(q => q.shuffledOptions)
            };
            localStorage.setItem('awsExamProgress', JSON.stringify(progress));
        }

        function loadProgress() {
            const saved = localStorage.getItem('awsExamProgress');
            if (saved) {
                const progress = JSON.parse(saved);
                currentQuestionIndex = progress.currentQuestionIndex;
                userAnswers = progress.userAnswers;
                questionOrder = progress.questionOrder;
                unansweredQuestions = progress.unansweredQuestions || [];
                elapsedTime = progress.elapsedTime || 0;
                examStartTime = progress.examStartTime;
                
                // Restore shuffled options
                if (progress.shuffledOptions) {
                    progress.shuffledOptions.forEach((opts, idx) => {
                        questions[idx].shuffledOptions = opts;
                    });
                }
                return true;
            }
            return false;
        }

        function clearProgress() {
            localStorage.removeItem('awsExamProgress');
        }

        function saveResult(score, correct, total, timeTaken) {
            const results = JSON.parse(localStorage.getItem('awsExamResults') || '[]');
            results.push({
                score,
                correct,
                total,
                timeTaken,
                date: new Date().toISOString(),
                passed: score >= 720
            });
            // Keep only last 10 results
            if (results.length > 10) {
                results.shift();
            }
            localStorage.setItem('awsExamResults', JSON.stringify(results));
        }

        function loadResults() {
            return JSON.parse(localStorage.getItem('awsExamResults') || '[]');
        }

        // Timer Functions
        function startTimer() {
            examStartTime = Date.now() - (elapsedTime * 1000);
            timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            if (isPaused) return;
            
            elapsedTime = Math.floor((Date.now() - examStartTime) / 1000);
            const remainingTime = Math.max(0, EXAM_DURATION - elapsedTime);
            const hours = Math.floor(remainingTime / 3600);
            const minutes = Math.floor((remainingTime % 3600) / 60);
            const seconds = remainingTime % 60;
            
            const timerDisplay = document.getElementById('timerDisplay');
            timerDisplay.textContent = 
                `‚è±Ô∏è Time Remaining: ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            
            // Update progress bar
            const progressFill = document.getElementById('timerProgressFill');
            const progressPercentage = (remainingTime / EXAM_DURATION) * 100;
            progressFill.style.width = `${progressPercentage}%`;
            
            // Color coding based on remaining time
            const timerContainer = timerDisplay.parentElement;
            progressFill.classList.remove('warning', 'critical');
            
            if (remainingTime <= 0) {
                timerContainer.style.background = 'rgba(239, 68, 68, 0.3)'; // Red
                timerDisplay.style.color = '#fef2f2';
                progressFill.classList.add('critical');
            } else if (remainingTime <= 600) { // 10 minutes or less
                timerContainer.style.background = 'rgba(239, 68, 68, 0.2)'; // Red
                timerDisplay.style.color = '#fee2e2';
                progressFill.classList.add('critical');
            } else if (remainingTime <= 1800) { // 30 minutes or less
                timerContainer.style.background = 'rgba(251, 191, 36, 0.2)'; // Yellow/Orange
                timerDisplay.style.color = '#fef3c7';
                progressFill.classList.add('warning');
            } else {
                timerContainer.style.background = 'rgba(255, 255, 255, 0.1)'; // Default
                timerDisplay.style.color = 'white';
            }
            
            saveProgress(); // Auto-save progress
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        // Activity Tracking Functions
        let activityThrottle = null;
        function trackActivity() {
            // Throttle activity updates to avoid excessive calls (especially from mousemove/scroll)
            if (!activityThrottle) {
                lastActivityTime = Date.now();
                activityThrottle = setTimeout(() => {
                    activityThrottle = null;
                }, 1000); // Update at most once per second
            }
        }

        function startActivityTracking() {
            // Track user interactions
            document.addEventListener('click', trackActivity);
            document.addEventListener('touchstart', trackActivity);
            document.addEventListener('keypress', trackActivity);
            document.addEventListener('mousemove', trackActivity);
            document.addEventListener('scroll', trackActivity);
            document.addEventListener('touchmove', trackActivity);
            
            // Check for inactivity every second
            activityCheckInterval = setInterval(checkActivity, 1000);
            
            // Track focus/blur events (desktop)
            window.addEventListener('blur', handleFocusLost);
            window.addEventListener('focus', handleFocusGained);
            
            // Track visibility changes (mobile - better support for closing apps)
            document.addEventListener('visibilitychange', handleVisibilityChange);
        }

        function stopActivityTracking() {
            document.removeEventListener('click', trackActivity);
            document.removeEventListener('touchstart', trackActivity);
            document.removeEventListener('keypress', trackActivity);
            document.removeEventListener('mousemove', trackActivity);
            document.removeEventListener('scroll', trackActivity);
            document.removeEventListener('touchmove', trackActivity);
            
            if (activityCheckInterval) {
                clearInterval(activityCheckInterval);
                activityCheckInterval = null;
            }
            
            window.removeEventListener('blur', handleFocusLost);
            window.removeEventListener('focus', handleFocusGained);
            document.removeEventListener('visibilitychange', handleVisibilityChange);
        }

        function handleFocusLost() {
            focusLostTime = Date.now();
        }

        function handleFocusGained() {
            focusLostTime = null;
            lastActivityTime = Date.now(); // Reset activity timer when coming back
        }

        function handleVisibilityChange() {
            if (document.hidden) {
                // Page is hidden (user switched tabs, closed app, or locked phone)
                focusLostTime = Date.now();
            } else {
                // Page is visible again
                focusLostTime = null;
                lastActivityTime = Date.now(); // Reset activity timer when coming back
            }
        }

        function checkActivity() {
            if (isPaused) return;
            
            const now = Date.now();
            const timeSinceActivity = (now - lastActivityTime) / 1000;
            const timeSinceFocusLost = focusLostTime ? (now - focusLostTime) / 1000 : 0;
            
            // Pause instantly on focus loss OR no activity for 2 minutes (while focused)
            if (timeSinceFocusLost > 0) {
                pauseExam('focus');
            } else if (timeSinceActivity >= 120) {
                pauseExam('inactivity');
            }
        }

        function pauseExam(reason) {
            isPaused = true;
            document.getElementById('pauseOverlay').classList.add('show');
            saveProgress();
            
            // Update pause message based on reason
            const pauseModal = document.querySelector('.pause-modal p');
            if (reason === 'focus') {
                pauseModal.textContent = 'The exam has been paused because you switched to another tab/app or locked your device.';
            } else if (reason === 'inactivity') {
                pauseModal.textContent = 'The exam has been paused due to 2 minutes of inactivity.';
            } else {
                pauseModal.textContent = 'The exam has been paused.';
            }
        }

        function resumeExam() {
            isPaused = false;
            document.getElementById('pauseOverlay').classList.remove('show');
            lastActivityTime = Date.now();
            focusLostTime = null;
            examStartTime = Date.now() - (elapsedTime * 1000); // Adjust start time
        }

        function confirmRestart() {
            if (confirm('Are you sure you want to restart? All current progress will be lost.')) {
                clearProgress();
                isPaused = false;
                document.getElementById('pauseOverlay').classList.remove('show');
                stopTimer();
                stopActivityTracking();
                location.reload();
            }
        }

        function startExam() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('examScreen').classList.remove('hidden');
            
            // Check if there's saved progress
            const hasProgress = loadProgress();
            
            if (!hasProgress) {
                // Keep questions in natural order 1-65 (not randomized)
                questionOrder = [...Array(questions.length).keys()]; // Creates [0, 1, 2, ..., 64]
                
                // Randomize answer options for each question
                questions.forEach(q => {
                    q.shuffledOptions = shuffle(q.options);
                });

                userAnswers = new Array(questions.length).fill(null);
                currentQuestionIndex = 0;
            }
            
            buildNavigation();
            loadQuestion();
            setupSwipeHandlers();
            startTimer();
            startActivityTracking();
        }

        function startNewExam() {
            if (confirm('Are you sure you want to start a new exam? Your current progress will be lost.')) {
                clearProgress();
                
                // Reset all state
                currentQuestionIndex = 0;
                userAnswers = [];
                questionOrder = [];
                unansweredQuestions = [];
                elapsedTime = 0;
                examStartTime = null;
                isPaused = false;
                
                // Start fresh exam
                startExam();
            }
        }

        function buildNavigation() {
            const grid = document.getElementById('questionGrid');
            grid.innerHTML = '';
            
            questions.forEach((_, index) => {
                const navItem = document.createElement('div');
                navItem.className = 'question-nav-item';
                navItem.textContent = index + 1;
                navItem.onclick = () => navigateToQuestion(index);
                grid.appendChild(navItem);
            });
        }

        function toggleNavigation() {
            const grid = document.getElementById('questionGrid');
            const btn = document.querySelector('.toggle-nav-btn');
            
            if (grid.classList.contains('show')) {
                grid.classList.remove('show');
                btn.textContent = 'Show All';
            } else {
                grid.classList.add('show');
                btn.textContent = 'Hide';
            }
        }

        function navigateToQuestion(index) {
            currentQuestionIndex = index;
            loadQuestion();
            // Auto-hide navigation after selection
            const grid = document.getElementById('questionGrid');
            const btn = document.querySelector('.toggle-nav-btn');
            grid.classList.remove('show');
            btn.textContent = 'Show All';
            // Scroll to top on mobile
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function updateNavigationHighlight() {
            const navItems = document.querySelectorAll('.question-nav-item');
            navItems.forEach((item, index) => {
                item.classList.remove('current', 'answered');
                
                if (index === currentQuestionIndex) {
                    item.classList.add('current');
                }
                
                if (userAnswers[index] !== null) {
                    item.classList.add('answered');
                }
            });
        }

        function loadQuestion() {
            const questionIndex = questionOrder[currentQuestionIndex];
            const question = questions[questionIndex];
            
            // Close materials modal if open
            closeMaterials();
            
            document.getElementById('questionType').textContent = `Question ${questionIndex + 1} ‚Ä¢ ${question.type}`;
            document.getElementById('questionText').textContent = question.question;
            document.getElementById('materialsContent').textContent = question.materials;
            
            const answersContainer = document.getElementById('answersContainer');
            answersContainer.innerHTML = '';
            
            question.shuffledOptions.forEach((option, index) => {
                const answerDiv = document.createElement('div');
                answerDiv.className = 'answer-option';
                answerDiv.onclick = () => selectAnswer(index, question.type);
                answerDiv.innerHTML = `
                    <div class="answer-checkbox"></div>
                    <div class="answer-text">${option.text}</div>
                `;
                answersContainer.appendChild(answerDiv);
            });

            // Restore previous selections if any
            if (userAnswers[questionIndex] !== null) {
                const selections = userAnswers[questionIndex];
                if (Array.isArray(selections)) {
                    selections.forEach(idx => {
                        answersContainer.children[idx].classList.add('selected');
                    });
                } else {
                    answersContainer.children[selections].classList.add('selected');
                }
            }

            updateProgress();
            updateNavigationHighlight();
            updateNavigationButtons();
            
            // Reset card animation
            const card = document.getElementById('questionCard');
            card.classList.remove('swipe-left', 'swipe-right');
            card.style.transform = '';
        }

        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            
            if (prevBtn && nextBtn) {
                // Disable previous button on first question
                prevBtn.disabled = currentQuestionIndex === 0;
                prevBtn.style.opacity = currentQuestionIndex === 0 ? '0.5' : '1';
                prevBtn.style.cursor = currentQuestionIndex === 0 ? 'not-allowed' : 'pointer';
                
                // Change next button text on last question
                if (currentQuestionIndex === questions.length - 1) {
                    nextBtn.textContent = 'Review & Submit ‚Üí';
                } else {
                    nextBtn.textContent = 'Next ‚Üí';
                }
            }
        }

        function selectAnswer(index, type) {
            const questionIndex = questionOrder[currentQuestionIndex];
            const answersContainer = document.getElementById('answersContainer');
            const options = answersContainer.children;

            if (type === 'Multiple Choice') {
                // Deselect all others
                Array.from(options).forEach(opt => opt.classList.remove('selected'));
                options[index].classList.add('selected');
                userAnswers[questionIndex] = index;
            } else {
                // Multiple Response - toggle selection
                options[index].classList.toggle('selected');
                
                // Get all selected indices
                const selected = [];
                Array.from(options).forEach((opt, idx) => {
                    if (opt.classList.contains('selected')) {
                        selected.push(idx);
                    }
                });
                
                userAnswers[questionIndex] = selected.length > 0 ? selected : null;
            }
            
            // Update navigation and save progress
            updateNavigationHighlight();
            saveProgress();
        }

        function toggleMaterials() {
            const overlay = document.getElementById('materialsOverlay');
            overlay.classList.add('show');
            
            // Scroll materials content to top
            const materialsContent = document.getElementById('materialsContent');
            materialsContent.scrollTop = 0;
            
            // Add keyboard listener for Escape key
            document.addEventListener('keydown', handleMaterialsEscape);
        }

        function closeMaterials() {
            const overlay = document.getElementById('materialsOverlay');
            overlay.classList.remove('show');
            // Remove keyboard listener
            document.removeEventListener('keydown', handleMaterialsEscape);
        }

        function closeMaterialsOnBackdrop(event) {
            if (event.target.id === 'materialsOverlay') {
                closeMaterials();
            }
        }

        function handleMaterialsEscape(event) {
            if (event.key === 'Escape') {
                closeMaterials();
            }
        }

        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                saveProgress();
                loadQuestion();
            }
        }

        function nextQuestion() {
            if (currentQuestionIndex < questions.length - 1) {
                currentQuestionIndex++;
                saveProgress();
                loadQuestion();
            } else {
                showSubmitScreen();
            }
        }


        function showSubmitScreen() {
            document.getElementById('examScreen').classList.add('hidden');
            document.getElementById('submitScreen').classList.add('show');
            
            const answeredCount = userAnswers.filter(a => a !== null).length;
            const unansweredCount = questions.length - answeredCount;
            
            document.getElementById('submitAnsweredCount').textContent = answeredCount;
            document.getElementById('submitUnansweredCount').textContent = unansweredCount;
            document.getElementById('submitTotalCount').textContent = questions.length;
            
            if (unansweredCount > 0) {
                document.getElementById('warningMessage').style.display = 'block';
            } else {
                document.getElementById('warningMessage').style.display = 'none';
            }
        }

        function backToExam() {
            document.getElementById('submitScreen').classList.remove('show');
            document.getElementById('examScreen').classList.remove('hidden');
            
            // Find first unanswered question or go to last question
            const firstUnanswered = userAnswers.findIndex(a => a === null);
            if (firstUnanswered !== -1) {
                currentQuestionIndex = firstUnanswered;
            } else {
                currentQuestionIndex = questions.length - 1;
            }
            
            loadQuestion();
        }

        function confirmSubmit() {
            if (confirm('Are you sure you want to submit your exam? This action cannot be undone.')) {
                showResults();
            }
        }

        function updateProgress() {
            const answeredCount = userAnswers.filter(a => a !== null).length;
            const progress = (answeredCount / questions.length) * 100;
            const currentQuestionNumber = questionOrder[currentQuestionIndex] + 1;
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('progressText').textContent = 
                `Question ${currentQuestionNumber} of ${questions.length} | ${answeredCount} answered`;
        }

        function setupSwipeHandlers() {
            const card = document.getElementById('questionCard');
            let isSwiping = false;
            let startTarget = null;
            
            card.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
                touchEndX = touchStartX; // Initialize to start position
                touchEndY = touchStartY;
                isSwiping = false;
                startTarget = e.target;
            }, false);

            card.addEventListener('touchmove', (e) => {
                // Check if touch started on an interactive element (but allow swipe-area)
                const isSwipeArea = startTarget.closest('.swipe-area');
                const isInteractive = startTarget.closest('.answer-option') || 
                                     startTarget.closest('.materials-btn') ||
                                     (startTarget.closest('button') && !isSwipeArea);
                
                if (isInteractive && !isSwipeArea) {
                    return; // Don't swipe if touching an interactive element
                }
                
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                
                // Only consider it a swipe if horizontal movement is greater than vertical
                // and movement is significant enough
                if (Math.abs(diffX) > 30 && Math.abs(diffX) > Math.abs(diffY)) {
                    isSwiping = true;
                    card.style.transform = `translateX(${diffX}px) rotate(${diffX / 20}deg)`;
                    e.preventDefault(); // Prevent scrolling during swipe
                }
            }, false);

            card.addEventListener('touchend', (e) => {
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                
                card.style.transform = '';
                
                // Only trigger swipe action if:
                // 1. User was actually swiping (not just tapping)
                // 2. Horizontal movement is significant (> 100px)
                // 3. Movement is primarily horizontal
                if (isSwiping && Math.abs(diffX) > 100 && Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX > 0) {
                        // Swipe right = previous
                        previousQuestion();
                    } else {
                        // Swipe left = next
                        nextQuestion();
                    }
                }
                
                // Reset all values
                touchStartX = 0;
                touchEndX = 0;
                touchStartY = 0;
                touchEndY = 0;
                isSwiping = false;
                startTarget = null;
            }, false);
        }

        function calculateScore() {
            let correct = 0;
            
            questions.forEach((question, index) => {
                const userAnswer = userAnswers[index];
                
                if (userAnswer === null) return;

                if (question.type === 'Multiple Choice') {
                    if (question.shuffledOptions[userAnswer].correct) {
                        correct++;
                    }
                } else {
                    // Multiple Response
                    const correctIndices = question.shuffledOptions
                        .map((opt, idx) => opt.correct ? idx : -1)
                        .filter(idx => idx !== -1);
                    
                    const userSelections = Array.isArray(userAnswer) ? userAnswer : [userAnswer];
                    
                    // Check if arrays match
                    if (correctIndices.length === userSelections.length &&
                        correctIndices.every(idx => userSelections.includes(idx))) {
                        correct++;
                    }
                }
            });

            // Calculate scaled score (100-1000, with 720 as passing)
            const percentage = correct / questions.length;
            const scaledScore = Math.round(100 + (percentage * 900));
            
            return { scaledScore, correct, total: questions.length };
        }

        function showResults() {
            // Stop timer and tracking
            stopTimer();
            stopActivityTracking();
            
            document.getElementById('submitScreen').classList.remove('show');
            document.getElementById('resultsScreen').classList.remove('show');
            
            const { scaledScore, correct, total } = calculateScore();
            const passed = scaledScore >= 720;

            // Save result to history
            saveResult(scaledScore, correct, total, elapsedTime);
            
            // Clear current progress
            clearProgress();

            document.getElementById('finalScore').textContent = scaledScore;
            document.getElementById('correctCount').textContent = correct;
            document.getElementById('totalCount').textContent = total;
            
            const passStatus = document.getElementById('passStatus');
            passStatus.textContent = passed ? '‚úì PASSED' : '‚úó FAILED';
            passStatus.className = 'pass-status ' + (passed ? 'pass' : 'fail');

            displayReview();
            displayPreviousResults();
            
            setTimeout(() => {
                document.getElementById('resultsScreen').classList.add('show');
            }, 100);
        }

        function displayPreviousResults() {
            const results = loadResults();
            const container = document.getElementById('resultsHistory');
            
            if (results.length === 0) {
                container.innerHTML = '<p style="opacity: 0.7; text-align: center;">No previous results yet.</p>';
                return;
            }
            
            container.innerHTML = '';
            
            // Display results in reverse order (newest first)
            results.reverse().forEach(result => {
                const date = new Date(result.date);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                const minutes = Math.floor(result.timeTaken / 60);
                const seconds = result.timeTaken % 60;
                const timeStr = `${minutes}:${String(seconds).padStart(2, '0')}`;
                
                const resultDiv = document.createElement('div');
                resultDiv.className = `result-item ${result.passed ? 'passed' : 'failed'}`;
                resultDiv.innerHTML = `
                    <div>
                        <div class="result-score">${result.score}/1000 ${result.passed ? '‚úì' : '‚úó'}</div>
                        <div class="result-date">${dateStr} ‚Ä¢ ${timeStr}</div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 14px;">${result.correct}/${result.total}</div>
                        <div style="font-size: 12px; opacity: 0.8;">${Math.round((result.correct/result.total)*100)}%</div>
                    </div>
                `;
                container.appendChild(resultDiv);
            });
        }

        function displayReview() {
            const reviewContainer = document.getElementById('reviewContainer');
            reviewContainer.innerHTML = '';

            questions.forEach((question, index) => {
                const userAnswer = userAnswers[index];
                const reviewDiv = document.createElement('div');
                reviewDiv.className = 'review-question';

                let userAnswerText = '';
                let correctAnswerText = '';
                let isCorrect = false;

                if (question.type === 'Multiple Choice') {
                    if (userAnswer !== null) {
                        userAnswerText = question.shuffledOptions[userAnswer].text;
                        isCorrect = question.shuffledOptions[userAnswer].correct;
                    } else {
                        userAnswerText = 'Not answered';
                    }
                    
                    const correctOption = question.shuffledOptions.find(opt => opt.correct);
                    correctAnswerText = correctOption.text;
                } else {
                    // Multiple Response
                    const correctOptions = question.shuffledOptions
                        .map((opt, idx) => opt.correct ? idx : -1)
                        .filter(idx => idx !== -1);
                    
                    if (userAnswer !== null) {
                        const userSelections = Array.isArray(userAnswer) ? userAnswer : [userAnswer];
                        userAnswerText = userSelections
                            .map(idx => question.shuffledOptions[idx].text)
                            .join(', ');
                        
                        isCorrect = correctOptions.length === userSelections.length &&
                                   correctOptions.every(idx => userSelections.includes(idx));
                    } else {
                        userAnswerText = 'Not answered';
                    }
                    
                    correctAnswerText = correctOptions
                        .map(idx => question.shuffledOptions[idx].text)
                        .join(', ');
                }

                let answerHTML = '';
                if (userAnswer === null) {
                    answerHTML = `<div class="review-answer wrong-answer">
                        <strong>Your Answer:</strong> Not answered
                    </div>`;
                } else if (isCorrect) {
                    answerHTML = `<div class="review-answer correct-answer">
                        <strong>Your Answer:</strong> ${userAnswerText} ‚úì
                    </div>`;
                } else {
                    answerHTML = `
                        <div class="review-answer wrong-answer">
                            <strong>Your Answer:</strong> ${userAnswerText} ‚úó
                        </div>
                        <div class="review-answer correct-answer">
                            <strong>Correct Answer:</strong> ${correctAnswerText}
                        </div>
                    `;
                }

                // Build explanations HTML
                let explanationsHTML = '<div class="explanation"><div class="explanation-title">Answer Explanations:</div>';
                question.shuffledOptions.forEach(option => {
                    const explanation = question.explanations[option.text];
                    if (explanation) {
                        explanationsHTML += `<p><strong>${option.text}:</strong> ${explanation}</p>`;
                    }
                });
                explanationsHTML += '</div>';

                const wasUnanswered = userAnswer === null ? '<span class="unanswered-tag">Unanswered</span>' : '';

                reviewDiv.innerHTML = `
                    <div class="review-question-number">Question ${index + 1} ${wasUnanswered}</div>
                    <div class="review-question-text">${question.question}</div>
                    ${answerHTML}
                    ${explanationsHTML}
                `;

                reviewContainer.appendChild(reviewDiv);
            });
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            const savedProgress = localStorage.getItem('awsExamProgress');
            if (savedProgress) {
                // Automatically resume the exam - go directly to it
                startExam();
            }
        });
    </script>
</body>
</html>

